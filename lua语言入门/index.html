<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Lua语言入门 - A few thoughts</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="ozryan"><meta name=description content="1 变量 变量名称 变量由字母、数字、下划线组成，但不能由数字开头，且不建议_A**这种下划线后接大写字母的方式，通常作为Lua内部特殊用途。下面的几个词是Lua保留的关键字：
">
<meta name=generator content="Hugo 0.88.1 with theme even">
<link rel=canonical href=https://www.fewth.com/lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link href=/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content="Lua语言入门">
<meta property="og:description" content="1 变量
变量名称
变量由字母、数字、下划线组成，但不能由数字开头，且不建议_A**这种下划线后接大写字母的方式，通常作为Lua内部特殊用途。下面的几个词是Lua保留的关键字：">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.fewth.com/lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2021-08-01T08:43:19+00:00">
<meta property="article:modified_time" content="2021-08-01T08:43:19+00:00">
<meta itemprop=name content="Lua语言入门">
<meta itemprop=description content="1 变量
变量名称
变量由字母、数字、下划线组成，但不能由数字开头，且不建议_A**这种下划线后接大写字母的方式，通常作为Lua内部特殊用途。下面的几个词是Lua保留的关键字："><meta itemprop=datePublished content="2021-08-01T08:43:19+00:00">
<meta itemprop=dateModified content="2021-08-01T08:43:19+00:00">
<meta itemprop=wordCount content="5762">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Lua语言入门">
<meta name=twitter:description content="1 变量
变量名称
变量由字母、数字、下划线组成，但不能由数字开头，且不建议_A**这种下划线后接大写字母的方式，通常作为Lua内部特殊用途。下面的几个词是Lua保留的关键字："><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>A few thoughts</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>主页</li>
</a><a href=/post>
<li class=mobile-menu-item>归档</li>
</a><a href=/categories/>
<li class=mobile-menu-item>分类</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>A few thoughts</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>主页</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post>归档</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>分类</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<header class=post-header>
<h1 class=post-title>Lua语言入门</h1>
<div class=post-meta>
<span class=post-time> 2021-08-01 </span>
<div class=post-category>
<a href=/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/> 编程语言特性 </a>
</div>
<span class=more-meta> 约 5762 字 </span>
<span class=more-meta> 预计阅读 12 分钟 </span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class="post-toc-content always-active">
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#1-变量>1 变量</a>
<ul>
<li><a href=#变量名称>变量名称</a></li>
<li><a href=#大小写>大小写</a></li>
<li><a href=#变量作用域>变量作用域</a></li>
<li><a href=#变量类型>变量类型</a></li>
</ul>
</li>
<li><a href=#2-注释>2 注释</a></li>
<li><a href=#3-语法>3 语法</a></li>
<li><a href=#4-io操作>4 I/O操作</a></li>
<li><a href=#5-metatable和metamethod>5 metatable和metamethod</a>
<ul>
<li><a href=#51-metatable>5.1 metatable</a></li>
<li><a href=#52-metamethod>5.2 metamethod</a></li>
</ul>
</li>
<li><a href=#6-面向对象>6 面向对象</a>
<ul>
<li><a href=#61-创建一个对象>6.1 创建一个对象</a></li>
<li><a href=#62-继承>6.2 继承</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<h2 id=1-变量>1 变量</h2>
<h3 id=变量名称>变量名称</h3>
<p>变量由字母、数字、下划线组成，但不能由数字开头，且不建议<code>_A**</code>这种下划线后接大写字母的方式，通常作为Lua内部特殊用途。下面的几个词是<code>Lua</code>保留的关键字：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>and or false true not repeat
if break do else elseif then end  for  goto while until in
local nil return function
</code></pre></td></tr></table>
</div>
</div><h3 id=大小写>大小写</h3>
<p><code>Lua</code>是大小写敏感的。</p>
<h3 id=变量作用域>变量作用域</h3>
<p><code>Lua</code>默认都是全局变量，包括在函数内声明的变量。<br>
本地变量以<code>local</code>开头，应该尽量使用<code>local</code>变量避免变量冲突。</p>
<p>变量不需要声明，直接使用即可，默认值是<code>nil</code>，给任何变量赋值<code>nil</code>等价于删除这个变量。</p>
<h3 id=变量类型>变量类型</h3>
<p><code>Lua</code>中有八种变量类型，分别是：</p>
<p><code>nil boolean number string userdata function thread table</code></p>
<p>可以用<code>type()</code>函数获取变量类型。</p>
<p><code>nil</code>:区别于任意变量类型的特殊类型，表示空值</p>
<p><code>boolean</code>:<code>Lua</code>中只有<code>false</code>和<code>nil</code>表示<code>false</code>，其余值都表示<code>true</code>,<code>and</code>和<code>or</code>是短路判断，<code>a and b</code>在<code>a</code>为真时返回<code>b</code>,<code>a</code>为假时返回a,<code>a or b</code>反之。<code>Lua</code>中不相等的判断符号是<code>~=</code>,其余的跟大部分语言没差别。</p>
<h4 id=number>number</h4>
<p>所有的整数和浮点数都可以用<code>number</code>表示，<code>3==3.0</code>也是<code>true</code>,<code>math.type</code>可以区别浮点数类型。</p>
<p><code>0x</code>开头表示16进制数，可以用<code>p*</code>的形式表示位移，正数表示左移，如<code>0x1p1</code>=4.0，<code>0x1p4</code>=16.0</p>
<p>支持常规四则运算，<code>//</code>（两个除号）可以表示向下（负无穷）取整，如<code>3//2</code>==1，<code>-3//2</code>=-2，<code>3//-2</code>=-2，跟取余计算有如下关系：</p>
<p><code>a % b == a - ((a // b) * b)</code></p>
<p>当<code>a,b</code>分别出现正负号时，有4种情况:</p>
<ul>
<li>a,b都为正，余数为正，<code>3%2=1</code></li>
<li>a,b都为负，<code>-3%-2=-1</code></li>
<li>a正b负，<code>3%-2=-1</code></li>
<li>a负b正，<code>-3%2=1</code></li>
</ul>
<p>总结一下就是，余数的符号跟除数一致。</p>
<h4 id=string>string</h4>
<p><code>string</code>实际上是<code>byte</code>的序列。</p>
<p><code>#s</code>可以获取字符串变量s内的长度，包含其中的空格等，返回的是<code>byte</code>的数量。</p>
<p>Lua的string跟java里一样,也是不可变的，但是可以通过函数用原来的字符串替换内容后生成新的字符串。</p>
<p><code>..</code>（两个点号）可以连接两个字符串，<code>"hello".." wolrd"->"hello world</code></p>
<p><code>tonumber</code>和<code>tostring</code>函数可以让字符串和数字相互转化。</p>
<h4 id=userdata>userdata</h4>
<p>可以保存任何<code>C</code>语言的数据</p>
<h4 id=function>function:</h4>
<p><code>function</code>可以传入任意数量的参数，多余的会被自动丢弃，没有传入的参数默认为<code>nil</code>。</p>
<p>函数可以有多个返回值，当函数作为中间过程调用时，只取第一个返回值，多返回值<strong>只在以下</strong>4个情况出现：</p>
<ul>
<li>多个变量接收返回值，此时多余的变量赋值为<code>nil</code>，多余的返回值被丢弃</li>
<li>作为另一个函数的参数传递，并且是最后一个传入的参数，如<code>g(a,b,f())</code></li>
<li>作为<code>table</code>构造时的参数,并且是最后一个传入的参数，如<code>tab={a,b,f()}</code></li>
<li>被<code>return</code>语句调用
上面的情况都必须是直接符合条件，不能有括号，比如<code>return (fun())</code>这里的<code>fun()</code>的返回值是先被<code>()</code>处理，而不是直接被<code>return</code>，所以只能返回第一个值</li>
</ul>
<p>函数可以接收变长参数，用<code>...</code>（3个点号）表示，可以直接使用，如<code>a,b=...</code>获取前两个参数。在函数体内用<code>{...}</code>的方式可以获取到所有参数的列表，然后用<code>ipairs{...}</code>的方式来遍历等，当然，如果参数包含<code>nil</code>这种方式就有缺陷，此时需要用<code>args=table.pack(...)</code>的方式获取参数，再用<code>args.n</code>获取参数数量，遍历排除<code>nil</code>。</p>
<h4 id=thread>thread:</h4>
<h4 id=table>table:</h4>
<p>一种强大的存储数据对象，用键值对的方式保存数据，除了<code>nil</code>以外的任何值都可以作为键。很像一个自动扩容的数组。</p>
<p>初始化方式为：<code>a={}</code>，初始化时可以带元素，没有指定<code>key</code>的数据从1开始按顺序排<code>key</code>,也可以用<code>key=value</code>这种键值对的方式传入多个初始化的数据。<code>key</code>可以用<code>[]</code>包裹，来使用表达式作为<code>key</code>。<br>
这里<code>a</code>只是一个指向这个<code>table</code>的变量，<code>table</code>本身是匿名的，借助<code>a</code>来操作这个<code>table</code>，如果所有指向这个<code>table</code>的变量都被赋值为<code>nil</code>，那么这个<code>table</code>的资源就会被系统回收。</p>
<p>浮点数和整数作为键时，如果值相等，则指向同一个index，比如<code>2.0</code>和<code>2</code>是相同的，这里键的判断跟<code>==</code>是一样的。</p>
<p><code>#</code>符号也可以获取<code>table</code>的长度，但是需要没有<code>nil</code>值在列表中间，这种连续存储的叫<strong>序列</strong>。如果想要获取有<code>nil</code>的<code>table</code>的长度，需要额外存放一个变量统计长度，并把它放在<code>table</code>中。</p>
<p>遍历<code>table</code>，可以用下面几种方式：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=kr>for</span> <span class=n>k</span><span class=p>,</span><span class=n>v</span> <span class=kr>in</span> <span class=n>pairs</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=kr>do</span> <span class=c1>-- 对任意table都有效，但不保证元素输出的顺序</span>
    <span class=c1>--dosth</span>
<span class=kr>end</span>

<span class=kr>for</span> <span class=n>k</span><span class=p>,</span><span class=n>v</span> <span class=kr>in</span> <span class=n>ipairs</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=kr>do</span> <span class=c1>--遍历列表</span>
    <span class=c1>--dosth</span>
<span class=kr>end</span>

<span class=kr>for</span> <span class=n>k</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span><span class=o>#</span><span class=n>a</span> <span class=kr>do</span>  <span class=c1>--对于没有nil值的序列</span>
    <span class=c1>--dosth</span>
<span class=kr>end</span>
</code></pre></td></tr></table>
</div>
</div><p>关于嵌套<code>table</code>的导航，可以用<code>or {}</code>的方式获取空值，避免报错和对前面层次的反复获取。</p>
<p><code>table</code>库有<code>insert,remove</code>等方法，具体用时可查。</p>
<h2 id=2-注释>2 注释</h2>
<p>单行注释用<code>--</code>开头。<br>
多行注释用<code>--[[</code>开头，直到<code>]]</code>结束。比如：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=cm>--[[
</span><span class=cm>    print(&#34;hello world&#34;);
</span><span class=cm>]]</span>
</code></pre></td></tr></table>
</div>
</div><p>多行注释的时候有个小技巧，把结尾的<code>]]</code>也用<code>--</code>开头，即：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=cm>--[[
</span><span class=cm>    print(&#34;hello world&#34;);
</span><span class=cm>--]]</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们需要取消注释的时候，在注释开头添加一个<code>-</code>即可，即<code>---[[</code>，因为这个操作会让<code>-[[</code>这几个字符变成了单行注释的内容，而结束的<code>--]]</code>也因为块注释的失效而变成了单行注释，此时<code>print</code>语句就生效了。当然，这种技巧应该只在调试的时候使用，重要的代码建议还是保持整结，这种方式看上去有点混乱。</p>
<h2 id=3-语法>3 语法</h2>
<p>分号和换行都不是必要的，内容用空格分隔即可，但是最好还是用行分隔或者分号分隔，显得清晰。</p>
<p>函数体和<code>if</code>语句等都有<code>end</code>标识符结尾。</p>
<h2 id=4-io操作>4 I/O操作</h2>
<p>简单版的基于<code>input</code>和<code>output</code>两个流来操作，基本只跟以下几个命令有关：</p>
<ul>
<li><code>io.input</code>:指定输入流来源，默认是标准输入</li>
<li><code>io.output()</code>:指定输出流目标，默认是标准输出（stardard output)</li>
<li><code>io.write</code>：写内容到输出流，需要<code>io.flush()</code>或者关闭流才能输出到文件</li>
<li><code>io.read()</code>:从输入流读取内容，根据传入的参数表现不同的读取方式：
<ul>
<li><code>"a"</code>：读取文件所有内容</li>
<li><code>"l"</code>:读一行，不包含换行符</li>
<li><code>"L"</code>:读一行，包含换行符</li>
<li><code>"n"</code>:读一个数字</li>
<li><code>n</code>：读取n个字符，这里的n表示数量</li>
</ul>
</li>
</ul>
<h2 id=5-metatable和metamethod>5 metatable和metamethod</h2>
<p><code>Lua</code>的面对向象主要是借助<code>table</code>实现的，在学习面向对象之前，先了解一下<code>metatable</code>相关的内容。</p>
<h3 id=51-metatable>5.1 metatable</h3>
<p><code>metatable</code>本身是一个普通的<code>table</code>，而<code>table</code>可以用一个<code>setmetatable</code>方法来设置自身的<code>metatable</code>值，<code>getmetatable</code>方法来获取相应的值。</p>
<p>只设置<code>metatable</code>属性是不够的，还需要结合对应的<code>metamethod</code>（元方法）。</p>
<h3 id=52-metamethod>5.2 metamethod</h3>
<p><code>Lua</code>内核原生支持以下几种方法(都是2个下划线开头）：</p>
<ul>
<li>算术操作符重载
<ul>
<li>
<p><code>__add</code>:给这个字段指定方法后，<code>+</code>操作就会使用这个方法来实现，默认情况下<code>table</code>是不支持<code>+</code>操作的。看下面的例子：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=n>Testtab</span><span class=o>=</span><span class=p>{};</span>
<span class=kd>local</span> <span class=n>mt</span><span class=o>=</span><span class=p>{};</span> <span class=c1>-- 初始化metatable</span>
<span class=n>Testtab.new</span><span class=o>=</span><span class=kr>function</span><span class=p>(</span><span class=n>t1</span><span class=p>)</span>
    <span class=kd>local</span> <span class=n>tab</span><span class=o>=</span><span class=p>{};</span>
    <span class=n>setmetatable</span><span class=p>(</span><span class=n>tab</span><span class=p>,</span><span class=n>mt</span><span class=p>);</span> <span class=c1>-- 设置metatable</span>
    <span class=kr>for</span> <span class=n>index</span><span class=p>,</span> <span class=n>value</span> <span class=kr>in</span> <span class=n>ipairs</span><span class=p>(</span><span class=n>t1</span><span class=p>)</span> <span class=kr>do</span>
        <span class=n>tab</span><span class=p>[</span><span class=o>#</span><span class=n>tab</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=n>value</span><span class=p>;</span>
    <span class=kr>end</span>
    <span class=kr>return</span> <span class=n>tab</span><span class=p>;</span>
<span class=kr>end</span>

<span class=kd>local</span> <span class=n>tab1</span><span class=o>=</span><span class=n>Testtab.new</span><span class=p>({</span><span class=mi>10</span><span class=p>,</span><span class=mi>20</span><span class=p>});</span>
<span class=kd>local</span> <span class=n>tab2</span><span class=o>=</span><span class=n>Testtab.new</span><span class=p>({</span><span class=mi>100</span><span class=p>,</span><span class=mi>200</span><span class=p>})</span>

<span class=c1>--以下两种实现方式的效果是一样的，输出合并后的结果</span>

<span class=c1>-- Testtab.merge=function (t1,t2)</span>
<span class=c1>--     local res={}</span>
<span class=c1>--     for index, value in ipairs(t1) do</span>
<span class=c1>--         res[#res+1] = value</span>
<span class=c1>--     end</span>
<span class=c1>--     for index, value in ipairs(t2) do</span>
<span class=c1>--         res[#res+1] = value</span>
<span class=c1>--     end</span>
<span class=c1>--     return res</span>
<span class=c1>-- end</span>
<span class=c1>-- mt.__add=Testtab.merge;</span>
<span class=c1>-- for index, value in ipairs(Testtab.merge(tab1,tab2)) do</span>
<span class=c1>--     print(value..&#34; &#34;)</span>
<span class=c1>-- end</span>

<span class=n>mt.__add</span><span class=o>=</span><span class=kr>function</span> <span class=p>(</span><span class=n>t1</span><span class=p>,</span><span class=n>t2</span><span class=p>)</span>
    <span class=kd>local</span> <span class=n>res</span><span class=o>=</span><span class=p>{}</span>
    <span class=kr>for</span> <span class=n>index</span><span class=p>,</span> <span class=n>value</span> <span class=kr>in</span> <span class=n>ipairs</span><span class=p>(</span><span class=n>t1</span><span class=p>)</span> <span class=kr>do</span>
        <span class=n>res</span><span class=p>[</span><span class=o>#</span><span class=n>res</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span>
    <span class=kr>end</span>
    <span class=kr>for</span> <span class=n>index</span><span class=p>,</span> <span class=n>value</span> <span class=kr>in</span> <span class=n>ipairs</span><span class=p>(</span><span class=n>t2</span><span class=p>)</span> <span class=kr>do</span>
        <span class=n>res</span><span class=p>[</span><span class=o>#</span><span class=n>res</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span>
    <span class=kr>end</span>
    <span class=kr>return</span> <span class=n>res</span>
<span class=kr>end</span>

<span class=kr>for</span> <span class=n>index</span><span class=p>,</span> <span class=n>value</span> <span class=kr>in</span> <span class=n>ipairs</span><span class=p>(</span><span class=n>tab1</span><span class=o>+</span><span class=n>tab2</span><span class=p>)</span> <span class=kr>do</span>
    <span class=n>print</span><span class=p>(</span><span class=n>value</span><span class=o>..</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
<span class=kr>end</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>__sub</code>：<code>-</code>减号操作，二元操作</p>
</li>
<li>
<p><code>__mul</code>: <code>*</code>乘号操作</p>
</li>
<li>
<p><code>__div</code>：<code>/</code>除号操作</p>
</li>
<li>
<p><code>__idiv</code>：<code>//</code>向下取整除号操作</p>
</li>
<li>
<p><code>__mod</code>：<code>%</code>取余操作</p>
</li>
<li>
<p><code>__unm</code>：<code>-</code>负号，一元操作符</p>
</li>
<li>
<p><code>__pow</code>：<code>^</code>指数操作</p>
</li>
</ul>
</li>
<li>位操作符重载
<ul>
<li><code>__band</code>：<code>&</code>按位与</li>
<li><code>__bor</code>：<code>|</code>按位或</li>
<li><code>__bxor</code>:<code>~</code>按位异或,<strong>二元操作</strong></li>
<li><code>__not</code>：<code>~</code>，按位取反，<strong>一元操作</strong></li>
<li><code>__shl</code>：<code>&lt;&lt;</code>位左移</li>
<li><code>__shr</code>：<code>>></code>位右移</li>
</ul>
</li>
<li><code>__concat</code>：连接</li>
<li><code>__len</code>:用<code>#</code>符号获取<code>table</code>长度时调用的方法</li>
<li><code>__pairs</code>：<code>for</code>循环时<code>pairs(k,v)</code>方法的重载</li>
<li>关系比较操作符重载<br>
下面这三个是关系比较操作符，这3个操作就可以解决所有情况，所以只需要实现这3个，剩下的情况可以通过组合这3个来实现。
<ul>
<li><code>__lt</code>：<code>&lt;</code>,less than</li>
<li><code>__le</code>：<code>&lt;=</code>,less or equal than</li>
<li><code>__eq</code>:<code>==</code>,equal</li>
</ul>
</li>
<li><code>table</code>元素读写
<ul>
<li>
<p><code>__index</code>：这个是<code>Lua</code>实现“继承”或者说“原型”的重要属性，当我们在<code>table</code>中读取一个不存在的元素，它就会尝试去<code>__index</code>中寻找，<code>__index</code>的值可以是一个<code>function</code>，也可以是另一个<code>table</code>，用<code>function</code>可以实现的功能更多更灵活，比如添加多个<code>table</code>实现“多继承”。<br>
如果我们只想查找<code>table</code>自己的数据，而不包含从<code>__index</code>“继承”的，那么用<code>rawget(t,i)</code>方法。</p>
</li>
<li>
<p><code>__newindex</code>：跟<code>__index</code>对应，这个操作是“写”相关的，当我们给<code>table</code>设置一个值，如果<code>key</code>不存在，那么会调用<code>__newindex</code>去完成这个操作。跟<code>__index</code>一样，值可以是<code>fuction</code>或者另一个<code>table</code>，<code>rawset</code>方法只写到原始<code>table</code>。一个简单的例子：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=n>SubA</span><span class=o>=</span><span class=p>{}</span>
<span class=n>ParentA</span><span class=o>=</span><span class=p>{}</span>
<span class=kd>local</span> <span class=n>mt</span><span class=o>=</span><span class=p>{}</span>
<span class=n>setmetatable</span><span class=p>(</span><span class=n>SubA</span><span class=p>,</span><span class=n>mt</span><span class=p>)</span>
<span class=n>mt.__index</span><span class=o>=</span><span class=n>ParentA</span>
<span class=c1>-- 下面的两种方式是一样的，注意fuction中的第一个参数mytable，它只是一个变量名，</span>
<span class=c1>--可以是table,tab,甚至 _ 等任意值，用来赋值的function格式就是这样的，</span>
<span class=c1>--__index中的function也类似</span>
<span class=n>mt.__newindex</span><span class=o>=</span><span class=n>ParentA</span>

<span class=c1>-- mt.__newindex=</span>
<span class=c1>-- function (mytable,k,v)</span>
<span class=c1>--     ParentA[k]=v</span>
<span class=c1>-- end</span>
<span class=n>SubA</span><span class=p>[</span><span class=s2>&#34;foo&#34;</span><span class=p>]</span><span class=o>=</span><span class=s2>&#34;bar&#34;</span>
<span class=n>print</span><span class=p>(</span><span class=n>SubA</span><span class=p>[</span><span class=s2>&#34;foo&#34;</span><span class=p>]);</span> <span class=c1>--&#34;bar&#34;,从ParentA里继承</span>
<span class=n>print</span><span class=p>(</span><span class=n>rawget</span><span class=p>(</span><span class=n>SubA</span><span class=p>,</span><span class=s2>&#34;foo&#34;</span><span class=p>))</span> <span class=c1>--nil，因为值设置到了ParentA里</span>
<span class=n>print</span><span class=p>(</span><span class=n>ParentA</span><span class=p>[</span><span class=s2>&#34;foo&#34;</span><span class=p>])</span> <span class=c1>--&#34;bar&#34;</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<p>总的来说，<code>metatable</code>里包含了各种约定<code>table</code>行为的数据。</p>
<h2 id=6-面向对象>6 面向对象</h2>
<p>在<a href=#5-metatable%E5%92%8Cmetamethod>metatable</a>的基础上，看一下<code>Lua</code>如何实现面向对象的。</p>
<p>首先，<code>Lua</code>里面没有<code>class</code>的概念，但是<code>__index</code>可以实现“继承”的功能，我们可以用这个属性去构造一个类似原型链的模型。</p>
<h3 id=61-创建一个对象>6.1 创建一个对象</h3>
<p>保存<code>table</code>的变量实际上是保存对这个<code>table</code>的引用，把这种变量赋值给另一个变量并不会产生新的<code>table</code>，而是对同一个<code>table</code>多了一个引用而已，所以下面的这种方式创建对象是<strong>不可行</strong>的：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=n>Person</span><span class=o>=</span><span class=p>{</span><span class=n>money</span><span class=o>=</span><span class=mi>0</span><span class=p>}</span>
<span class=n>p1</span><span class=o>=</span><span class=n>Person</span>
<span class=n>p1.money</span><span class=o>=</span><span class=mi>20</span>
<span class=n>print</span><span class=p>(</span><span class=n>Person.money</span><span class=p>)</span> <span class=c1>--输出20,因为两者指向的是同一个table</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以写一个<code>new</code>方法来返回一个新的对象：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=n>Person</span><span class=o>=</span><span class=p>{</span><span class=n>money</span><span class=o>=</span><span class=mi>0</span><span class=p>}</span>
<span class=n>Person.new</span><span class=o>=</span><span class=kr>function</span><span class=p>(){</span>
    <span class=n>obj</span><span class=o>=</span><span class=p>{}</span> <span class=c1>--一个新的table,用来返回新的对象</span>
    <span class=n>mt</span><span class=o>=</span><span class=p>{}</span> <span class=c1>--metatable</span>
    <span class=n>setmetatable</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span><span class=n>mt</span><span class=p>)</span> <span class=c1>--设置metatable</span>
    <span class=n>mt.__index</span><span class=o>=</span><span class=n>Person</span> <span class=c1>--设置obj的“原型”为Person</span>
    <span class=kr>return</span> <span class=n>obj</span>
<span class=p>}</span>

<span class=n>p1</span><span class=o>=</span><span class=n>Person.new</span>
<span class=n>p1.money</span><span class=o>=</span><span class=mi>20</span>
<span class=n>print</span><span class=p>(</span><span class=n>Person.money</span><span class=p>)</span> <span class=c1>--0，p1是一个新创建的table，跟Person已经不是同一个</span>
</code></pre></td></tr></table>
</div>
</div><p>加入一个<code>new</code>方法解决了属性的问题，但“对象的方法”仍然存在问题，给上面的例子加一个方法：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=n>Person</span><span class=o>=</span><span class=p>{</span><span class=n>money</span><span class=o>=</span><span class=mi>0</span><span class=p>}</span>
<span class=n>Person.new</span><span class=o>=</span><span class=kr>function</span> <span class=p>()</span>
    <span class=n>obj</span><span class=o>=</span><span class=p>{}</span>
    <span class=n>mt</span><span class=o>=</span><span class=p>{}</span>
    <span class=n>setmetatable</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span><span class=n>mt</span><span class=p>)</span>
    <span class=n>mt.__index</span><span class=o>=</span><span class=n>Person</span>
    <span class=kr>return</span> <span class=n>obj</span>
<span class=kr>end</span>

<span class=n>Person.add</span><span class=o>=</span><span class=kr>function</span> <span class=p>(</span><span class=n>n</span><span class=p>)</span>
    <span class=n>Person.money</span><span class=o>=</span><span class=n>Person.money</span><span class=o>+</span><span class=n>n</span>
<span class=kr>end</span>
<span class=n>p1</span><span class=o>=</span><span class=n>Person.new</span><span class=p>()</span>
<span class=n>p2</span><span class=o>=</span><span class=n>Person.new</span><span class=p>()</span>
<span class=n>p1.add</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> <span class=c1>--把money添加到了Person.moeny中</span>
<span class=n>print</span><span class=p>(</span><span class=s2>&#34;p1&#39;s money:&#34;</span><span class=o>..</span><span class=n>p1.money</span><span class=p>)</span>
<span class=n>print</span><span class=p>(</span><span class=s2>&#34;p2&#39;s money:&#34;</span><span class=o>..</span><span class=n>p2.money</span><span class=p>)</span>
<span class=n>print</span><span class=p>(</span><span class=s2>&#34;Person&#39;s money:&#34;</span><span class=o>..</span><span class=n>Person.money</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><p>例子中，因为我们的<code>add</code>方法是对<code>Person.money</code>硬编码的，导致所有由<code>Person.new</code>生成的对象，在使用<code>add</code>方法时，都把<code>money</code>的值加到了<code>Person.money</code>上，这样显然是不行的，可以通过在方法中传入一个当前对象的引用来解决：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=n>Person</span><span class=o>=</span><span class=p>{</span><span class=n>money</span><span class=o>=</span><span class=mi>0</span><span class=p>}</span>
<span class=n>Person.new</span><span class=o>=</span><span class=kr>function</span> <span class=p>()</span>
    <span class=n>obj</span><span class=o>=</span><span class=p>{}</span>
    <span class=n>mt</span><span class=o>=</span><span class=p>{}</span>
    <span class=n>setmetatable</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span><span class=n>mt</span><span class=p>)</span>
    <span class=n>mt.__index</span><span class=o>=</span><span class=n>Person</span>
    <span class=kr>return</span> <span class=n>obj</span>
<span class=kr>end</span>

<span class=n>Person.add</span><span class=o>=</span><span class=kr>function</span> <span class=p>(</span><span class=n>self</span><span class=p>,</span><span class=n>n</span><span class=p>)</span>
    <span class=n>self.money</span><span class=o>=</span><span class=n>self.money</span><span class=o>+</span><span class=n>n</span>
<span class=kr>end</span>
<span class=n>p1</span><span class=o>=</span><span class=n>Person.new</span><span class=p>()</span>
<span class=n>p2</span><span class=o>=</span><span class=n>Person.new</span><span class=p>()</span>
<span class=n>p1.add</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span><span class=mi>10</span><span class=p>)</span> 
<span class=n>print</span><span class=p>(</span><span class=s2>&#34;p1&#39;s money:&#34;</span><span class=o>..</span><span class=n>p1.money</span><span class=p>)</span>
<span class=n>print</span><span class=p>(</span><span class=s2>&#34;p2&#39;s money:&#34;</span><span class=o>..</span><span class=n>p2.money</span><span class=p>)</span>
<span class=n>print</span><span class=p>(</span><span class=s2>&#34;Person&#39;s money:&#34;</span><span class=o>..</span><span class=n>Person.money</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><p>修改后的例子中的<code>add</code>方法，传入了一个<code>self</code>参数，每次调用方法时，都会把<code>money</code>加到<code>self</code>的<code>money</code>属性上。这里的<code>self</code>参数，当显式的传入时，可以用任何名称，不过还可以通过<code>:</code>（冒号）符号隐式的调用，但是方法的定义只能是<code>function obj:fun_name</code>的方式（前面的例子中<code>Person.add=funtion()</code>和<code>function Person.add()</code>都是可以的,<code>add</code>方法可以改成下面这样，效果跟上面是一样的：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=kr>function</span> <span class=nc>Person</span><span class=p>:</span><span class=nf>add</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=c1>-- 隐式的传入参数self</span>
    <span class=n>self.money</span><span class=o>=</span><span class=n>self.money</span><span class=o>+</span><span class=n>n</span>
<span class=kr>end</span>

<span class=c1>-- p1.add(p1,10)===p1:add(10)</span>
</code></pre></td></tr></table>
</div>
</div><p>还有两个可以优化的点：</p>
<ul>
<li><code>new</code>方法可以传入参数，实现“有参”构造函数的功能</li>
<li><code>metatable</code>实际上也是一个普通的<code>table</code>，我们完全可以用对象本身的<code>table</code>来完成这个功能，也就是引入<code>self</code>参数，所以<code>new</code>方法也用<code>:</code>的方式定义和调用</li>
</ul>
<p>优化后的类如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=n>Person</span><span class=o>=</span><span class=p>{</span><span class=n>money</span><span class=o>=</span><span class=mi>0</span><span class=p>}</span>
<span class=kr>function</span> <span class=nc>Person</span><span class=p>:</span><span class=nf>new</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
    <span class=n>obj</span><span class=o>=</span><span class=n>obj</span> <span class=ow>or</span> <span class=p>{}</span> <span class=c1>--如果没有传入参数，则obj=nil,根据or的短路判断，初始化为{}，</span>
    <span class=n>self.__index</span><span class=o>=</span><span class=n>self</span> <span class=c1>--把self当作metatable,设置它的__index属性为self自身指向的table，节省一个table变量的命名</span>
    <span class=n>setmetatable</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span><span class=n>self</span><span class=p>)</span> <span class=c1>--给obj设置metatable，结合__index属性，obj相当于“继承”了self(也就是Person)的内容</span>
    <span class=kr>return</span> <span class=n>obj</span>
<span class=kr>end</span>


<span class=kr>function</span> <span class=nc>Person</span><span class=p>:</span><span class=nf>add</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
    <span class=n>self.money</span><span class=o>=</span><span class=n>self.money</span><span class=o>+</span><span class=n>n</span>
<span class=kr>end</span>

<span class=n>p1</span><span class=o>=</span><span class=n>Person</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
<span class=n>p2</span><span class=o>=</span><span class=n>Person</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
<span class=n>p1</span><span class=p>:</span><span class=n>add</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> 
<span class=n>print</span><span class=p>(</span><span class=s2>&#34;p1&#39;s money:&#34;</span><span class=o>..</span><span class=n>p1.money</span><span class=p>)</span>
<span class=n>print</span><span class=p>(</span><span class=s2>&#34;p2&#39;s money:&#34;</span><span class=o>..</span><span class=n>p2.money</span><span class=p>)</span>
<span class=n>print</span><span class=p>(</span><span class=s2>&#34;Person&#39;s money:&#34;</span><span class=o>..</span><span class=n>Person.money</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=62-继承>6.2 继承</h3>
<p>继承也是用<code>__index</code>这个属性实现的，其实确切的说，这个模型更接近原型链。看一下例子：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=n>Person</span><span class=o>=</span><span class=p>{</span><span class=n>money</span><span class=o>=</span><span class=mi>100</span><span class=p>}</span>
<span class=kr>function</span> <span class=nc>Person</span><span class=p>:</span><span class=nf>new</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
    <span class=n>obj</span><span class=o>=</span><span class=n>obj</span> <span class=ow>or</span> <span class=p>{}</span>
    <span class=n>self.__index</span><span class=o>=</span><span class=n>self</span>
    <span class=n>setmetatable</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span><span class=n>self</span><span class=p>)</span>
    <span class=kr>return</span> <span class=n>obj</span>
<span class=kr>end</span>


<span class=kr>function</span> <span class=nc>Person</span><span class=p>:</span><span class=nf>add</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
    <span class=n>self.money</span><span class=o>=</span><span class=n>self.money</span><span class=o>+</span><span class=n>n</span>
<span class=kr>end</span>

<span class=n>Employee</span><span class=o>=</span><span class=n>Person</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
<span class=kr>function</span> <span class=nc>Employee</span><span class=p>:</span><span class=nf>say</span><span class=p>()</span>
    <span class=n>print</span><span class=p>(</span><span class=s2>&#34;I have &#34;</span><span class=o>..</span><span class=n>self.money</span><span class=o>..</span><span class=s2>&#34; dollors&#34;</span><span class=p>)</span>
<span class=kr>end</span>
<span class=n>e</span><span class=o>=</span><span class=n>Employee</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
<span class=n>e</span><span class=p>:</span><span class=n>add</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
<span class=n>e</span><span class=p>:</span><span class=n>say</span><span class=p>()</span> <span class=c1>-- I have 200 dollors</span>
</code></pre></td></tr></table>
</div>
</div><p>例子中的几个关键步骤：</p>
<ol>
<li><code>Employee=Person:new()</code>，这里调用的是<code>Person</code>的方法，所以隐式传入的<code>self</code>指向的是<code>Person</code>，方法返回一个<code>obj</code>，这个<code>obj</code>的<code>metatable</code>的<code>__index</code>指向了<code>Person</code>（这里<code>self</code>是<code>Person</code>）。因为我们没有传入其它参数，所以<code>Employee</code>指向的是一个空的<code>table</code>，但是“继承”了<code>Person</code></li>
<li><code>e=Employee:new()</code>，<code>Employee</code>先去调用<code>new</code>方法，发现自身并没有这个方法，然后通过<code>metatalbe</code>指定<code>__index</code>属性去它的“原型”里面查找，找到了<code>Person</code>里的<code>new</code>方法，并使用这个方法。值得注意的是，调用<code>new</code>方法时隐式传入的<code>self</code>对象是<code>Employee</code>而不是<code>Person</code>,因为我们就是在<code>Employee</code>上调用的<code>new</code>方法，只是它通过“继承”获取到了方法,这一步返回一个空的<code>table</code>，但是它“继承”了<code>Employee</code>。</li>
<li><code>e:add(100)</code>，跟上面类似，先查找<code>Employee</code>，发现没有<code>add</code>方法，然后查找<code>Person</code>，找到后调用，此时传入的<code>self</code>是<code>e</code>本身，调用方法时发现自身还没有<code>money</code>这个属性，继续往上查找，找到<code>Person</code>的<code>money</code>，值是<code>100</code>,然后相加，得<code>200</code></li>
</ol>
</div>
<footer class=post-footer>
<nav class=post-nav>
<a class=prev href=/spring-boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/>
<i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Spring Boot启动流程</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/%E5%9B%9E%E6%BA%AFbacktracking/>
<span class="next-text nav-default">回溯(backtracking)</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i>
</a>
</nav>
</footer>
</article>
</div>
<div id=vcomments></div>
<script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script>
<script src=//unpkg.com/valine/dist/Valine.min.js></script>
<script type=text/javascript>new Valine({el:'#vcomments',appId:'BmT2lGTnBMBj6625uiiWM1xV-MdYXbMMI',appKey:'tasHQvivyFQEjq66DERC31Ja',notify:!1,verify:!1,avatar:'mm',placeholder:'说点什么吧...',visitor:!1})</script>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=https://github.com/ozryan class="iconfont icon-github" title=github></a>
<a href=https://www.fewth.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=copyright>
<span class=power-by>
由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动
</span>
<span class=division>|</span>
<span class=theme-info>
主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span>
<span class=copyright-year>
&copy;
2020 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>ozryan</span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script>
<script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script>
</body>
</html>