<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>JVM之运行时数据区域 - A few thoughts</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="ozryan"><meta name=description content="Java11虚拟机规范中描述的，当执行一个程序时需要用到的几个运行时数据区域，具体的虚拟机实现可能并没有严格按照这个划分。
">
<meta name=generator content="Hugo 0.88.1 with theme even">
<link rel=canonical href=https://www.fewth.com/jvm%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link href=/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content="JVM之运行时数据区域">
<meta property="og:description" content="Java11虚拟机规范中描述的，当执行一个程序时需要用到的几个运行时数据区域，具体的虚拟机实现可能并没有严格按照这个划分。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.fewth.com/jvm%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2021-08-15T13:48:20+00:00">
<meta property="article:modified_time" content="2021-08-15T13:48:20+00:00">
<meta itemprop=name content="JVM之运行时数据区域">
<meta itemprop=description content="Java11虚拟机规范中描述的，当执行一个程序时需要用到的几个运行时数据区域，具体的虚拟机实现可能并没有严格按照这个划分。"><meta itemprop=datePublished content="2021-08-15T13:48:20+00:00">
<meta itemprop=dateModified content="2021-08-15T13:48:20+00:00">
<meta itemprop=wordCount content="2967">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="JVM之运行时数据区域">
<meta name=twitter:description content="Java11虚拟机规范中描述的，当执行一个程序时需要用到的几个运行时数据区域，具体的虚拟机实现可能并没有严格按照这个划分。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>A few thoughts</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>主页</li>
</a><a href=/post>
<li class=mobile-menu-item>归档</li>
</a><a href=/categories/>
<li class=mobile-menu-item>分类</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>A few thoughts</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>主页</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post>归档</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>分类</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<header class=post-header>
<h1 class=post-title>JVM之运行时数据区域</h1>
<div class=post-meta>
<span class=post-time> 2021-08-15 </span>
<div class=post-category>
<a href=/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/> 编程语言特性 </a>
</div>
<span class=more-meta> 约 2967 字 </span>
<span class=more-meta> 预计阅读 6 分钟 </span>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class="post-toc-content always-active">
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#1-程序计数器the-program-counter-register>1 程序计数器(The Program Counter Register)</a></li>
<li><a href=#2-虚拟机栈java-virtual-machine-stacks>2 虚拟机栈(Java Virtual Machine Stacks)</a>
<ul>
<li><a href=#21-栈帧frame>2.1 栈帧(Frame)</a></li>
</ul>
</li>
<li><a href=#3-本地方法栈native-method-stacks>3 本地方法栈(Native Method Stacks)</a></li>
<li><a href=#4-堆heap>4 堆(Heap)</a>
<ul>
<li><a href=#41-方法区method-area>4.1 方法区(Method Area)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<p><a href=https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5>Java11虚拟机规范</a>中描述的，当执行一个程序时需要用到的几个运行时数据区域，具体的虚拟机实现可能并没有严格按照这个划分。</p>
<h2 id=1-程序计数器the-program-counter-register>1 程序计数器(The Program Counter Register)</h2>
<p>这个区域存储的是当前线程执行的指令位置，以便在线程切换时可以快速恢复。</p>
<p>JVM是支持多线程的，而这个多线程执行的方式可能是以下3种（参见<a href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html>JLS chapter 17</a>）:</p>
<ul>
<li>由多个硬件处理器直接支持</li>
<li>单个处理器用轮流分配时间切片的方式实现</li>
<li>多个处理器用轮流分配时间切片的方式实现</li>
</ul>
<p>首先，第一种情况理论上只适用于虚拟机线程数量很少的情况，因为通常硬件处理器核心数量不会很多。而后面两种情况，当线程分配到的时间切片用完时，线程执行会暂停，等待下一个时间切片，当线程恢复执行时，就需要用计数器中存储的信息来定位指令执行的位置，程序计数器是<strong>每个线程一个</strong>,是<strong>线程私有</strong>的。</p>
<p>当虚拟机线程执行方法<code>a</code>时，可能会调用其它方法比如<code>b</code>，那么当<code>b</code>激活时<code>a</code>就会暂停，同一时间同一个虚拟机线程只会执行一个方法，如果正在执行的方法不是<code>native</code>的，则记录指令执行的位置，如果是<code>native</code>的，则值是<code>undefined</code>，因为<code>native</code>的方法是外部实现的，并不是虚拟机可以理解的字节码指令。</p>
<p>规范指出该区域足够大，可以处理任意大小指令地址<code>returnAddress</code>，并不会抛出<code>OutOfMemoryError</code>异常。</p>
<h2 id=2-虚拟机栈java-virtual-machine-stacks>2 虚拟机栈(Java Virtual Machine Stacks)</h2>
<p>最早的版本也曾命名为“Java Stack”。</p>
<p>当一个虚拟机线程执行一个方法时，除了用程序计数器保存指令地址外，还需要保存方法的内部变量、过程值等，这些信息就以 <strong>栈帧(stack frame)</strong> 的形式保存在虚拟机栈里面，这个区域也是 <strong>线程私有</strong> 的。</p>
<p>虚拟机栈的操作只有压入和弹出栈帧，所以这个区域的占用的内存不需要是连续的。</p>
<p>虚拟机规范允许厂商在实现虚拟机时把虚拟机栈的大小设置成固定的或者可以根据计算过程动态扩展和收缩的，虚拟机可能会提供参数，让我们调节虚拟机栈的初始大小，以及动态扩展和收缩的时的上下限等。</p>
<p>异常：</p>
<ul>
<li>如果虚拟机计算过程中需要用到的虚拟机栈大小大于虚拟机允许的值，则抛出<code>StackOverflowError</code></li>
<li>如果给虚拟机栈设置初始大小时，无法申请到足够的内存，或者动态扩展申请内存失败，则抛出<code>OutOfMemoryError</code></li>
</ul>
<h3 id=21-栈帧frame>2.1 栈帧(Frame)</h3>
<p>栈帧是虚拟机栈中存储的“基本单位”，上面提到，同一个虚拟机线程在同一时间只会执行一个方法，而每个方法在调用时就会创建一个对应的栈帧，在方法退出时(正常执行结束或者被异常中断)清除栈帧。当方法<code>a</code>执行时，对应的栈帧<code>fa</code>创建并处于激活状态，而当方法<code>a</code>调用方法<code>b</code>时，会创建新的栈帧<code>fb</code>，此时<code>fb</code>激活，<code>fa</code>就不是激活状态了，直到方法<code>b</code>退出，<code>fb</code>被清除，<code>fa</code>重新激活，方法<code>a</code>继续执行。</p>
<p>栈帧通常用来存储<strong>本地变量</strong>、<strong>操作数栈</strong>、以及协助<strong>动态链接</strong>、<strong>方法调用</strong>等，虚拟机实现方也可以添加一些自定义的信息，比如<code>debug</code>信息等。</p>
<ul>
<li>
<p>本地变量(local variables):本地变量以数组的形式保存，它的大小在编译时就确定了。保存的类形可以是8个基本类型<code>boolean,btye,short,int,long,float,double,char</code>和<code>reference</code>,<code>returnAddress</code>，其中<code>long</code>和<code>double</code>占用两个单位槽的位置，其它的占用一个槽，占用两个槽的值可以从起始槽<code>n</code>处读取，但不能从<code>n+1</code>读取，而<code>n+1</code>的位置可以被写入其它内容，一旦写了值，原来<code>n</code>处占用两个槽的值就被破坏了。<br>
当调用一个方法时，参数和内部变量等都保存在<code>local variable</code>中，其中第0个变量指向<code>this</code>，其它的按出现顺序排列。<code>class</code>文件中的<code>LocalVariableTable</code>就是本地变量。</p>
</li>
<li>
<p>操作数栈(oprand stacks):操作数栈就是用先进后出的栈的形式保存，栈的最大深度在编译时就确定了。当栈帧刚创建时，操作数栈是空的，然后在需要时通过加载指令把本地变量的值压入栈，其它的一些指令，如<code>iadd</code>就会弹出栈顶的两个值，相加后把结果压入栈顶。</p>
</li>
</ul>
<blockquote>
<p>说到<code>iadd</code>指令顺便提一下java中的自动类型提升：因为虚拟机中的操作指令都是用两个16进制数表示的，也就是说，上限只能有256个指令，除去保留的(202,254,255)3个指令，从0到201全部已经使用，所以对于不太常用的<code>short,char,boolean,byte</code>几个类型的操作，都只有<code>bipush,sipush</code>等压入操作，并且在压入时自动提升为<code>int</code>类型，后续操作再根据需要转化，所以在代码中<code>short i=1000;short j=2000;i=i+j;</code>这样的写法就会出错，因为<code>i+j</code>在操作时已经是<code>int</code>类型，需要进行转化<code>i=(short)(i+j)</code>。这里的不常用是针对相加等操作来说，这几个类型存在的意义在于，用于数组存储时，它们仍然可以节省空间，并且也有相应的<code>baload,saload</code>等读取操作指令。</p>
</blockquote>
<ul>
<li>
<p>动态链接(dynamic linking):栈帧中包含对常量池的引用，以便完成动态链接。当方法中包含对其它类型或者方法等引用时，代码中保存的只是符号引用，需要通过对常量池的读取和操作来完成动态链接，这个过程可能又会触发其它类的加载等，最终让符号引用变成当前方法可以具体使用的类或者方法。</p>
</li>
<li>
<p>方法调用：当前方法<code>a</code>去调用方法<code>b</code>时，栈帧<code>fa</code>会保存当前的本地变量和操作数栈等信息，当方法<code>b</code>执行结束时，用这些信息恢复方法<code>a</code>的状态继续执行，此时程序计数器会正确增加，然后跳过对方法<code>b</code>的调用这条指令，并且方法<code>b</code>返回的结果会压入<code>fa</code>的操作数栈。如果方法<code>b</code>抛出异常，则<code>fb</code>被清空弹出，异常由方法<code>a</code>接手，如果方法<code>a</code>也无法处理，<code>fa</code>也清空并弹出，直到线程中没有栈帧，或者异常被处理。</p>
</li>
</ul>
<h2 id=3-本地方法栈native-method-stacks>3 本地方法栈(Native Method Stacks)</h2>
<p>本地方法栈跟虚拟机栈类似，只是它对应的是<code>native</code>方法，也就是非并用<code>Java</code>语言实现的方法。如果虚拟机本身不支持<code>native</code>方法，则没有这个区域。</p>
<p>它的大小等设置也是由虚拟机实现方决定，有的虚拟机可能把这个区域和虚拟机栈混合在一起。</p>
<p>跟虚拟机栈一样，可能会抛出<code>StackOverflowError</code>或者<code>OutOfMemoryError</code>。</p>
<h2 id=4-堆heap>4 堆(Heap)</h2>
<p>堆是所有线程共享的，运行时的所有类的<strong>实例</strong>和数组，都是在堆上分配的空间。堆在虚拟机启动时创建，并且是垃圾回收机制作用的主要区域，虚拟机规范没有限定如何实现垃圾回收机制。</p>
<p>堆的大小可以是固定的或者动态扩展和收缩的，以及可以提供参数让我们控制相应大小等，这些都由虚拟机实现厂商决定。</p>
<p>堆所需的空间不必是连续的。</p>
<p>当程序计算过程中需要的堆大小超出了限定值，则抛出<code>OutOfMemoryError</code>异常。</p>
<h3 id=41-方法区method-area>4.1 方法区(Method Area)</h3>
<p>方法区是堆的一部分，大小分配等也由虚拟机实现方决定，但<strong>部分虚拟机实现可能不在方法区执行垃圾回收</strong>。可以理解为跟<code>class</code>文件相关的内容存放的方法区中，而类的实例等存在堆的其它地方。</p>
<p>如果方法区的大小无法满足使用要求，则抛出<code>OutOfMemoryError</code>异常。</p>
<h4 id=411-运行时常量池run-time-constant-pool>4.1.1 运行时常量池(Run-Time Constant Pool)</h4>
<p>运行时常量池则是方法区的一部分，我们在<code>class</code>文件中可以看到常量池的存在。每个类或者接口都对应一个常量池，虚拟机在创建类或者接口时构建运行时常量池。</p>
<p>如果构建运行时常量池时，方法区无法提供足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p>
</div>
<footer class=post-footer>
<nav class=post-nav>
<a class=prev href=/jvm%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/>
<i class="iconfont icon-left"></i>
<span class="prev-text nav-default">JVM之自动内存管理(垃圾回收机制)</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/spring-boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/>
<span class="next-text nav-default">Spring Boot启动流程</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i>
</a>
</nav>
</footer>
</article>
</div>
<div id=vcomments></div>
<script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script>
<script src=//unpkg.com/valine/dist/Valine.min.js></script>
<script type=text/javascript>new Valine({el:'#vcomments',appId:'BmT2lGTnBMBj6625uiiWM1xV-MdYXbMMI',appKey:'tasHQvivyFQEjq66DERC31Ja',notify:!1,verify:!1,avatar:'mm',placeholder:'说点什么吧...',visitor:!1})</script>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=https://github.com/ozryan class="iconfont icon-github" title=github></a>
<a href=https://www.fewth.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=copyright>
<span class=copyright-year>
&copy;
2020 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>ozryan</span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script>
<script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script>
</body>
</html>