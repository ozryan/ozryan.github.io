<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title> - Spring Boot启动流程</title>

      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">

          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js" integrity="sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy" crossorigin="anonymous"></script>
              
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
                  onload="renderMathInElement(document.body);"></script>
              
          
      

      
          <link rel="stylesheet" href="https:&#x2F;&#x2F;www.fewth.com&#x2F;site.css">
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="/" class="logo">Even</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;www.fewth.com">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;www.fewth.com&#x2F;categories">
                            Categories
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;www.fewth.com&#x2F;tags">
                            Tags
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;www.fewth.com&#x2F;about">
                            About
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;www.fewth.com">Even</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;www.fewth.com">
                                    Home
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;www.fewth.com&#x2F;categories">
                                    Categories
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;www.fewth.com&#x2F;tags">
                                    Tags
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;www.fewth.com&#x2F;about">
                                    About
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#1-xin-jian-xiang-mu" class="toc-link">1 新建项目</a>
                    
                </li>
                
                <li>
                    <a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2-fen-xi-yuan-ma" class="toc-link">2 分析源码</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2-1-shi-li-hua-springapplication" class="toc-link">2.1 实例化SpringApplication</a>
                        </li>
                        
                        <li>
                            <a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2-2-yun-xing-runfang-fa" class="toc-link">2.2 运行run方法</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#3-zong-jie" class="toc-link">3 总结</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;www.fewth.com&#x2F;spring-bootqi-dong-liu-cheng&#x2F;">Spring Boot启动流程</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2021-08-14</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>本文用一个空的<code>Spring Boot</code>项目演示，从<code>main</code>方法开始顺着源码大概过一遍启动流程。</p>
<!--more-->
<h2 id="1-xin-jian-xiang-mu">1 新建项目</h2>
<p>从<a href="https://start.spring.io/">spring initializr</a>下载一个demo。我这里选的是<code>java11,maven,spring boot2.4.5</code>,dependencies里面选<code>Spring Web</code>。
启动项目以后在<code>Demo</code>文件夹内新建一个<code>HelloController</code></p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span style="color:#c0c5ce;">com.example.demo;

</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">org.springframework.web.bind.annotation.</span><span style="color:#ebcb8b;">GetMapping</span><span style="color:#c0c5ce;">;
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">org.springframework.web.bind.annotation.</span><span style="color:#ebcb8b;">RestController</span><span style="color:#c0c5ce;">;

@</span><span style="color:#bf616a;">RestController
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">HelloController </span><span style="color:#eff1f5;">{
    @</span><span style="color:#bf616a;">GetMapping</span><span style="color:#eff1f5;">(</span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">/</span><span style="color:#c0c5ce;">&quot;</span><span style="color:#eff1f5;">)
    </span><span style="color:#b48ead;">public </span><span style="color:#ebcb8b;">String </span><span style="color:#8fa1b3;">hello</span><span style="color:#eff1f5;">(){
        </span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;</span><span style="color:#eff1f5;">;
    }
}
</span></code></pre>
<p>启动项目，打开http://localhost:8080/，看到hello说明成功。</p>
<h2 id="2-fen-xi-yuan-ma">2 分析源码</h2>
<p>首先，<code>main</code>方法里只有一个调用<code>SpringApplication.run(DemoApplication.class, args)</code>，这里调用<code>SpringApplication</code>类的<code>run</code>方法，，<code>run</code>是一个静态方法，会触发<code>SpringApplication</code>类的初始化，具体初始化的内容后面用到的部分再说，<code>run</code>方法传入两个参数：</p>
<ul>
<li><code>DemoApplication.class</code>，当前类的<code>Class</code>对象</li>
<li><code>args</code>，<code>main</code>方法传递的参数，这里是空</li>
</ul>
<p>查看<code>run</code>方法，内部调用的最终形式为：<br />
<code>new SpringApplication(primarySources).run(args);</code><br />
这可以分成两步，第一步是实例化<code>SpringApplication</code>，第二步调用对象的<code>run</code>方法，这里的两个参数分别是：</p>
<ul>
<li>primarySources:new Class&lt;?&gt;[]{DemoApplication.class}，把当前启动类的Class传入一个 <code>Class[]</code>数组</li>
<li>args:null，我们的demo里没有传入参数</li>
</ul>
<h3 id="2-1-shi-li-hua-springapplication">2.1 实例化SpringApplication<span id="2.1"/></h3>
<p>我们先来看<code>SpringApplication</code>的实例化，最终执行实例化的是下面这段代码：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">public </span><span style="color:#bf616a;">SpringApplication</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ResourceLoader</span><span style="color:#c0c5ce;"> resourceLoader, </span><span style="color:#ebcb8b;">Class</span><span style="color:#c0c5ce;">&lt;?&gt;... primarySources) {
    </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.resourceLoader = resourceLoader;</span><span style="color:#65737e;">//null
    </span><span style="color:#ebcb8b;">Assert</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">notNull</span><span style="color:#c0c5ce;">(primarySources, &quot;</span><span style="color:#a3be8c;">PrimarySources must not be null</span><span style="color:#c0c5ce;">&quot;);</span><span style="color:#65737e;">//检查变量确保不为空

    //把传入的参数放入一个Set&lt;Class&lt;?&gt;&gt;,Set中只有一个值：DemoApplication.class
    </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.primarySources = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LinkedHashSet</span><span style="color:#c0c5ce;">&lt;&gt;(</span><span style="color:#ebcb8b;">Arrays</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">asList</span><span style="color:#c0c5ce;">(primarySources));

    </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.webApplicationType = </span><span style="color:#ebcb8b;">WebApplicationType</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">deduceFromClasspath</span><span style="color:#c0c5ce;">();</span><span style="color:#65737e;">//2.1.1
    
    </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.bootstrapRegistryInitializers = </span><span style="color:#bf616a;">getBootstrapRegistryInitializersFromSpringFactories</span><span style="color:#c0c5ce;">();</span><span style="color:#65737e;">//2.1.2
    </span><span style="color:#bf616a;">setInitializers</span><span style="color:#c0c5ce;">((</span><span style="color:#ebcb8b;">Collection</span><span style="color:#c0c5ce;">) </span><span style="color:#bf616a;">getSpringFactoriesInstances</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ApplicationContextInitializer</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">));</span><span style="color:#65737e;">//2.1.3
    </span><span style="color:#bf616a;">setListeners</span><span style="color:#c0c5ce;">((</span><span style="color:#ebcb8b;">Collection</span><span style="color:#c0c5ce;">) </span><span style="color:#bf616a;">getSpringFactoriesInstances</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ApplicationListener</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">));</span><span style="color:#65737e;">//2.1.4
    </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.mainApplicationClass = </span><span style="color:#bf616a;">deduceMainApplicationClass</span><span style="color:#c0c5ce;">();</span><span style="color:#65737e;">//2.1.5
</span><span style="color:#c0c5ce;">}
</span></code></pre>
<p>实例化的过程中初始化了几个属性：</p>
<h4 id="2-1-1-webapplicationtype">2.1.1 <span id="2.1.1">webApplicationType</span></h4>
<p><code>WebApplicatonType</code>是一个<code>Enum</code>类型，有三个值：<code>REACTIVE</code>,<code>SERVLET</code>,<code>NONE</code>，通过<code>deduceFromClasspath()</code>方法推断类型。</p>
<ul>
<li><code>deduceFromClasspath()</code>引用<code>ClassUtils</code>类的<code>isPresent(String className, @Nullable ClassLoader classLoader)</code>方法来判断<code>className</code>对应的类是否存在，<code>className</code>是预定义的几个静态常量之一，这些常量的值是类的全限定名，<code>WebApplicatonType</code>通过判断这几个常量对应的类是否存在来推断<code>WebApplicatonType</code>的类型，具体逻辑看源码。
我们这里的结果是<code>WebApplicatonType.SERVLET</code></li>
</ul>
<h4 id="2-1-2-bootstrapregistryinitializers">2.1.2 bootstrapRegistryInitializers</h4>
<p>先看一下调用的方法：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">private </span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">BootstrapRegistryInitializer</span><span style="color:#c0c5ce;">&gt; </span><span style="color:#bf616a;">getBootstrapRegistryInitializersFromSpringFactories</span><span style="color:#c0c5ce;">() {
  </span><span style="color:#65737e;">//创建一个ArrayList用来保存结果
  </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">BootstrapRegistryInitializer</span><span style="color:#c0c5ce;">&gt; initializers = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;&gt;();

  </span><span style="color:#bf616a;">getSpringFactoriesInstances</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">Bootstrapper</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">).</span><span style="color:#bf616a;">stream</span><span style="color:#c0c5ce;">()
      .</span><span style="color:#bf616a;">map</span><span style="color:#c0c5ce;">((</span><span style="color:#bf616a;">bootstrapper</span><span style="color:#c0c5ce;">) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#c0c5ce;">((</span><span style="color:#ebcb8b;">BootstrapRegistryInitializer</span><span style="color:#c0c5ce;">) bootstrapper::</span><span style="color:#bf616a;">initialize</span><span style="color:#c0c5ce;">))
      .</span><span style="color:#bf616a;">forEach</span><span style="color:#c0c5ce;">(initializers::</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">);
  initializers.</span><span style="color:#bf616a;">addAll</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">getSpringFactoriesInstances</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">BootstrapRegistryInitializer</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">));
  </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> initializers;
}
</span></code></pre>
<p><code>getSpringFactoriesInstances(Bootstrapper.class)</code>这个方法，会尝试去项目的classpath下查找所有在<code>spring.factoires</code>文件中指定的<code>Bootstrapper.class</code>的实现类，后面的链式操作会根据结果获取对应的<code>BootstrapRegistryInitializer</code>并添加到返回值<code>initializers</code>中，<code>Bootstrapper</code>在springboot2.4.4以后标记为deprecated,并计划在2.6移除，由后面的<code>BootstrapRegistryInitializer</code>取代。</p>
<p>我们的demo中，下面的两个包内有<span id="springfactories"><code>META-INF/spring.factories</code></span>这个文件：</p>
<ul>
<li>spring-boot-2.4.5.jar</li>
<li>spring-boot-autoconfigure-2.4.5.jar</li>
</ul>
<p>这一步并没有查找到相应的<code>BootstrapRegistryInitializer</code>，返回值为一个空的<code>ArrayList</code></p>
<h4 id="2-1-3-setinitializers">2.1.3 <span id="2.1.3">setInitializers</span></h4>
<p>这一步设置的是<code>private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers</code>这个字段，方法跟前面一样，通过查找<code>spring.factories</code>文件来取得相应的实现类，<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#springfactories">上面提到的两个文件</a>中都有<code>ApplicationContextInitializer.class</code>的信息，分别是：</p>
<pre style="background-color:#2b303b;">
<code class="language-yml" data-lang="yml"><span style="color:#65737e;">#spring-boot-2.4.5.jar/META-INF/spring.factories
</span><span style="color:#a3be8c;">org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer

</span><span style="color:#65737e;">#spring-boot-autoconfigure-2.4.5.jar/META-INF/spring.factories
</span><span style="color:#a3be8c;">org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener
</span></code></pre>
<p>所以这一步初始化了<code>initializers</code>，其列表包含7个实现类的信息。</p>
<h4 id="2-1-4-setlisteners">2.1.4 <span id="2.1.4">setListeners</span></h4>
<p>跟<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2.1.3">setInitializers</a>类似，这一步初始化了<code>private List&lt;ApplicationListener&lt;?&gt;&gt; listeners</code>这个字段，列表包含9个实现类的信息。</p>
<h4 id="2-1-5-mainapplicationclass">2.1.5 mainApplicationClass</h4>
<p>通过<code>StackTraceElement</code>的反射信息来推判主启动类，这里是<code>com.example.demo.DemoApplication.class</code></p>
<h3 id="2-2-yun-xing-runfang-fa">2.2 运行run方法</h3>
<p>run方法比前面的实例化过程要复杂，先看一下方法的主体：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">public </span><span style="color:#ebcb8b;">ConfigurableApplicationContext </span><span style="color:#bf616a;">run</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;">... args) {
  </span><span style="color:#ebcb8b;">StopWatch</span><span style="color:#c0c5ce;"> stopWatch = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">StopWatch</span><span style="color:#c0c5ce;">();</span><span style="color:#65737e;">//实例化一个计时器
</span><span style="color:#c0c5ce;">  stopWatch.</span><span style="color:#bf616a;">start</span><span style="color:#c0c5ce;">();</span><span style="color:#65737e;">//启动计时器

  </span><span style="color:#ebcb8b;">DefaultBootstrapContext</span><span style="color:#c0c5ce;"> bootstrapContext = </span><span style="color:#bf616a;">createBootstrapContext</span><span style="color:#c0c5ce;">();</span><span style="color:#65737e;">//2.2.1
  </span><span style="color:#ebcb8b;">ConfigurableApplicationContext</span><span style="color:#c0c5ce;"> context = </span><span style="color:#d08770;">null</span><span style="color:#c0c5ce;">;</span><span style="color:#65737e;">//初始化context
  </span><span style="color:#bf616a;">configureHeadlessProperty</span><span style="color:#c0c5ce;">();</span><span style="color:#65737e;">//2.2.2
  </span><span style="color:#ebcb8b;">SpringApplicationRunListeners</span><span style="color:#c0c5ce;"> listeners = </span><span style="color:#bf616a;">getRunListeners</span><span style="color:#c0c5ce;">(args);</span><span style="color:#65737e;">//2.2.3
</span><span style="color:#c0c5ce;">  listeners.</span><span style="color:#bf616a;">starting</span><span style="color:#c0c5ce;">(bootstrapContext, </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.mainApplicationClass);</span><span style="color:#65737e;">//2.2.3
  </span><span style="color:#b48ead;">try </span><span style="color:#c0c5ce;">{
    </span><span style="color:#ebcb8b;">ApplicationArguments</span><span style="color:#c0c5ce;"> applicationArguments = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">DefaultApplicationArguments</span><span style="color:#c0c5ce;">(args);</span><span style="color:#65737e;">//2.2.4
    </span><span style="color:#ebcb8b;">ConfigurableEnvironment</span><span style="color:#c0c5ce;"> environment = </span><span style="color:#bf616a;">prepareEnvironment</span><span style="color:#c0c5ce;">(listeners, bootstrapContext, applicationArguments);</span><span style="color:#65737e;">//2.2.5
    </span><span style="color:#bf616a;">configureIgnoreBeanInfo</span><span style="color:#c0c5ce;">(environment); </span><span style="color:#65737e;">// 2.2.6
    </span><span style="color:#ebcb8b;">Banner</span><span style="color:#c0c5ce;"> printedBanner = </span><span style="color:#bf616a;">printBanner</span><span style="color:#c0c5ce;">(environment); </span><span style="color:#65737e;">//获取banner
</span><span style="color:#c0c5ce;">    context = </span><span style="color:#bf616a;">createApplicationContext</span><span style="color:#c0c5ce;">(); </span><span style="color:#65737e;">// 2.2.7
</span><span style="color:#c0c5ce;">    context.</span><span style="color:#bf616a;">setApplicationStartup</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.applicationStartup); </span><span style="color:#65737e;">// 2.2.8
    </span><span style="color:#bf616a;">prepareContext</span><span style="color:#c0c5ce;">(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); </span><span style="color:#65737e;">//2.2.9
    </span><span style="color:#bf616a;">refreshContext</span><span style="color:#c0c5ce;">(context); </span><span style="color:#65737e;">// 2.2.10
    </span><span style="color:#bf616a;">afterRefresh</span><span style="color:#c0c5ce;">(context, applicationArguments); </span><span style="color:#65737e;">// 示例中为空
</span><span style="color:#c0c5ce;">    stopWatch.</span><span style="color:#bf616a;">stop</span><span style="color:#c0c5ce;">(); </span><span style="color:#65737e;">// 停止计时器
    // 在控制台打印计时器的启动时间信息
    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.logStartupInfo) {
      </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">StartupInfoLogger</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.mainApplicationClass).</span><span style="color:#bf616a;">logStarted</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">getApplicationLog</span><span style="color:#c0c5ce;">(), stopWatch);
    }

    </span><span style="color:#65737e;">// 通知对应的监听器，表明context已经启动,示例中ApplicationStartedEvent事件对应的监听器没有操作，只触发了AvailabilityChangeEvent事件，表明context正确运行，并在ApplicationAvailabilityBean的events属性中记录相应信息，状态：事件的AMP
</span><span style="color:#c0c5ce;">    listeners.</span><span style="color:#bf616a;">started</span><span style="color:#c0c5ce;">(context); 
    </span><span style="color:#bf616a;">callRunners</span><span style="color:#c0c5ce;">(context, applicationArguments); </span><span style="color:#65737e;">// 示例中这一步为空。调用ApplicationRunner和CommandLineRunner类型的run方法
  </span><span style="color:#c0c5ce;">}
  </span><span style="color:#b48ead;">catch </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">Throwable </span><span style="color:#bf616a;">ex</span><span style="color:#c0c5ce;">) {
    </span><span style="color:#bf616a;">handleRunFailure</span><span style="color:#c0c5ce;">(context, ex, listeners);
    </span><span style="color:#b48ead;">throw new </span><span style="color:#ebcb8b;">IllegalStateException</span><span style="color:#c0c5ce;">(ex);
  }

  </span><span style="color:#b48ead;">try </span><span style="color:#c0c5ce;">{
    listeners.</span><span style="color:#bf616a;">running</span><span style="color:#c0c5ce;">(context); </span><span style="color:#65737e;">//　通知对应的监听器，表明context已经在运行，跟前面的started类似，这里ApplicationReadyEvent事件对应的监听器没有操作，更新了context的状态ReadinessState.ACCEPTING_TRAFFIC
  </span><span style="color:#c0c5ce;">}
  </span><span style="color:#b48ead;">catch </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">Throwable </span><span style="color:#bf616a;">ex</span><span style="color:#c0c5ce;">) {
    </span><span style="color:#bf616a;">handleRunFailure</span><span style="color:#c0c5ce;">(context, ex, </span><span style="color:#d08770;">null</span><span style="color:#c0c5ce;">);
    </span><span style="color:#b48ead;">throw new </span><span style="color:#ebcb8b;">IllegalStateException</span><span style="color:#c0c5ce;">(ex);
  }
  </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> context; </span><span style="color:#65737e;">// 2.2.11
</span><span style="color:#c0c5ce;">}
</span></code></pre>
<p>方法的返回值是<code>ConfigurableApplicationContext</code>，也就是我们的spring容器，方法中的所有步骤都是为这个结果做准备的。上面不重要的步骤用注释带过，复杂点的分别说明。</p>
<h4 id="2-2-1-bootstrapcontext">2.2.1 bootstrapContext</h4>
<p>这个变量的类型是<code>DefaultBootstrapContext</code>，它跟<code>ApplicationContext</code>不是同一个分支，只是实现了<code>BootstrapRegistry</code>和<code>BootstrapContext</code>这两个接口，里面的功能很相对较少。</p>
<p>变量的值来自方法<code>createBootstrapContext()</code>，实现如下：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">private </span><span style="color:#ebcb8b;">DefaultBootstrapContext </span><span style="color:#bf616a;">createBootstrapContext</span><span style="color:#c0c5ce;">() {
  </span><span style="color:#ebcb8b;">DefaultBootstrapContext</span><span style="color:#c0c5ce;"> bootstrapContext = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">DefaultBootstrapContext</span><span style="color:#c0c5ce;">();
  </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.bootstrapRegistryInitializers.</span><span style="color:#bf616a;">forEach</span><span style="color:#c0c5ce;">((</span><span style="color:#bf616a;">initializer</span><span style="color:#c0c5ce;">) </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> initializer.</span><span style="color:#bf616a;">initialize</span><span style="color:#c0c5ce;">(bootstrapContext));
  </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> bootstrapContext;
}
</span></code></pre>
<p>这个方法先是实例化一个<code>DefaultBootstrapContext</code>对象，然后再尝试用<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2.1.2-bootstrapRegistryInitializers">2.1.2</a>描述过的<code>bootstrapRegistryInitializers</code>变量内的实现类去挨个的尝试初始化这个<code>context</code>，但是由前面的分析得知，变量是空的列表，所以这一步被跳过。</p>
<p>方法返回一个默认构造函数构造的<code>DefaultBootstrapContext</code>对象。</p>
<h4 id="2-2-2-configureheadlessproperty">2.2.2 configureHeadlessProperty()</h4>
<p>尝试设置系统属性<code>java.awt.headless</code>，从而打开headless模式。看方法代码：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">private</span><span style="color:#c0c5ce;"> void </span><span style="color:#bf616a;">configureHeadlessProperty</span><span style="color:#c0c5ce;">() {
  </span><span style="color:#ebcb8b;">System</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">setProperty</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">SYSTEM_PROPERTY_JAVA_AWT_HEADLESS</span><span style="color:#c0c5ce;">,
      </span><span style="color:#ebcb8b;">System</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">getProperty</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">SYSTEM_PROPERTY_JAVA_AWT_HEADLESS</span><span style="color:#c0c5ce;">, </span><span style="color:#ebcb8b;">Boolean</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">toString</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.headless)));
}
</span></code></pre>
<p><code>SYSTEM_PROPERTY_JAVA_AWT_HEADLESS</code>是常量字符串<code>&quot;java.awt.headless&quot;</code>，<code>headless</code>的初始化值是<code>true</code>。</p>
<p>从上面的代码可以看出来，方法会首先从系统属性中获取<code>java.awt.headless</code>的值，如果已经被设置，就不会去覆盖，只有在没有设置的情况下才会设置成<code>true</code>。</p>
<p>为什么 spring boot 要设置headless模式呢？<br />
首先，headless模式的好处在于，如果你的代码需要调用图形界面，那么当运行这段代码的时候，就会直接抛出<code>java.awt.HeadlessException</code>这个异常，headless模式不允许代码去尝试调用图形界面相关功能。<br />
spring boot程序通常都运行在服务器上，服务器没有图形显示功能很正常。如果没有headless模式，可能我们的代码里出现了调用图形界面的情况，然后在PC上调试没有问题，打包到服务器运行的时候，服务器会尝试去调用图形界面功能，发现没有，然后报出相应的错误。</p>
<p>可以用docker模拟服务器环境，Dockerfile内容如下，放在jar包同目录：</p>
<pre style="background-color:#2b303b;">
<code class="language-docker" data-lang="docker"><span style="color:#c0c5ce;">FROM openjdk:11.0.11-oracle
WORKDIR /
ADD demo-0.0.1-SNAPSHOT.jar demo.jar
EXPOSE 8080
CMD [&quot;java&quot;, &quot;-Djava.awt.headless=false&quot;, &quot;-jar&quot;, &quot;demo.jar&quot;]
</span></code></pre>
<p><code>-Djava.awt.headless=false</code>这个参数可以在启动时（显然在spring boot前）设置<code>java.awt.headless</code>属性，避免被覆盖。</p>
<p>运行<code>docker build ./ -t demo</code>生成镜像，然后运行<code>docker run -p 8080:8080 demo</code>启动测试。</p>
<blockquote>
<p>PS:这里可以用JOptionPane.showMessageDialog(new Frame(),&quot;showMessage&quot;);这行代码去测试,它会弹出一个窗口,并且只有点击这个窗口的OK键程序才会继续执行(有时候弹出的窗口并没有在最顶层,用alt+tab键在所有窗口中找一下)。把这行代码分别放在SpringApplication.run(DemoApplication.class, args);之前，和放HelloController的return语句之前，也就是在spring 容器外和容器内分别测试，后者的报错信息量大且没有前者提示明显，也就是不开启headless模式更容易出现的情况。</p>
</blockquote>
<h4 id="2-2-3-listeners">2.2.3 listeners</h4>
<p>注意：这是<code>run</code>方法内的<strong>局部变量</strong>，虽然名称跟前面<code>SpringApplication</code>对象的字段一样(<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2.1.4">2.1.4 setListeners</a>)</p>
<p>这里的<code>listeners</code>声明为<code>SpringApplicationRunListeners</code>类型，这个类型封装了一组<code>SpringApplicationRunListener</code>监听器(针对SpringApplication<code>run</code>方法的监听器)。</p>
<h5 id="2-2-3-1-sheng-ming-bing-chu-shi-hua-listenersbian-liang">2.2.3-1 声明并初始化listeners变量</h5>
<p><code>SpringApplicationRunListeners listeners = getRunListeners(args)</code><br />
用<code>getRunListeners</code>方法来初始化，方法实现如下：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">private </span><span style="color:#ebcb8b;">SpringApplicationRunListeners </span><span style="color:#bf616a;">getRunListeners</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[]</span><span style="color:#c0c5ce;"> args) {
  </span><span style="color:#ebcb8b;">Class</span><span style="color:#c0c5ce;">&lt;?&gt;</span><span style="color:#b48ead;">[]</span><span style="color:#c0c5ce;"> types = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Class</span><span style="color:#c0c5ce;">&lt;?&gt;[] { </span><span style="color:#ebcb8b;">SpringApplication</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, </span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[]</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class </span><span style="color:#c0c5ce;">};
  </span><span style="color:#b48ead;">return new </span><span style="color:#ebcb8b;">SpringApplicationRunListeners</span><span style="color:#c0c5ce;">(logger,
      </span><span style="color:#bf616a;">getSpringFactoriesInstances</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">SpringApplicationRunListener</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, types, </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">, args),
      </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.applicationStartup);
}
</span></code></pre>
<p>实际上就是调用构造函数，<code>logger</code>是在<code>SpringApplication</code>进于类初始化的时候设置好的字段: <code>private static final Log logger = LogFactory.getLog(SpringApplication.class);</code>，日志主要是记录失败相关的信息</p>
<p><code>getSpringFactoriesInstances</code>方法中的参数是为了匹配类的构造函数，<span id="2.2.3-1-listenerimpl">这里只有一个监听器实现类</span><code>org.springframework.boot.context.event.EventPublishingRunListener</code>,匹配到<code>public EventPublishingRunListener(SpringApplication application, String[] args)</code>这个构造函数进行实例化</p>
<h5 id="2-2-3-2-listeners-starting-bootstrapcontext-this-mainapplicationclass">2.2.3-2 listeners.starting(bootstrapContext, this.mainApplicationClass)</h5>
<p>调用<code>SpringApplicationRunListeners</code>的<code>starting</code>方法：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#c0c5ce;">void </span><span style="color:#bf616a;">starting</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ConfigurableBootstrapContext</span><span style="color:#c0c5ce;"> bootstrapContext, </span><span style="color:#ebcb8b;">Class</span><span style="color:#c0c5ce;">&lt;?&gt; mainApplicationClass) {
  </span><span style="color:#bf616a;">doWithListeners</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">spring.boot.application.starting</span><span style="color:#c0c5ce;">&quot;, (</span><span style="color:#bf616a;">listener</span><span style="color:#c0c5ce;">) </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> listener.</span><span style="color:#bf616a;">starting</span><span style="color:#c0c5ce;">(bootstrapContext),
      (</span><span style="color:#bf616a;">step</span><span style="color:#c0c5ce;">) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#c0c5ce;">{
        </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(mainApplicationClass != </span><span style="color:#d08770;">null</span><span style="color:#c0c5ce;">) {
          step.</span><span style="color:#bf616a;">tag</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">mainApplicationClass</span><span style="color:#c0c5ce;">&quot;, mainApplicationClass.</span><span style="color:#bf616a;">getName</span><span style="color:#c0c5ce;">());
        }
      });
}
</span></code></pre>
<p><code>doWithListeners</code>会遍历每一个<code>SpringApplicationRunListeners</code>的实现类，调用其<code>starting</code>方法，
<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2.2.3-1-listenerimpl">上面</a>提到只有一个实现类<code>EventPublishingRunListener</code>，它的<code>starting</code>方法如下：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">public</span><span style="color:#c0c5ce;"> void </span><span style="color:#bf616a;">starting</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ConfigurableBootstrapContext</span><span style="color:#c0c5ce;"> bootstrapContext) {
  </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.initialMulticaster
      .</span><span style="color:#bf616a;">multicastEvent</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ApplicationStartingEvent</span><span style="color:#c0c5ce;">(bootstrapContext, </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.application, </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.args));
}
</span></code></pre>
<p><code>initialMulticaster.multicastEvent</code>的作用就是把<code>ApplicationStartingEvent</code>这个启动事件传播给所有的支持这个事件的监听器，这些监听器是从<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2.1.4">前面</a><code>SpringApplication</code>实例化时得到的9个监听器中筛选出来的(筛选过程就是判断监听器是否支持事件本身以及其source的类型)，筛选后的监听器会去判断自身是否含有处理这个事件的代码，如果有，则执行相应的逻辑，在这个例子中只有<code>org.springframework.boot.context.logging.LoggingApplicationListener</code>有相应的逻辑。</p>
<h4 id="2-2-4-applicationarguments-applicationarguments-new-defaultapplicationarguments-args">2.2.4 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args)</h4>
<p>把<code>args</code>参数包装在<code>ApplicationArguments</code>里面，这里args的值是空的Sttring[]</p>
<h4 id="2-2-5-prepareenvironment">2.2.5 prepareEnvironment</h4>
<p><code>ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments)</code></p>
<p>3个参数在前面都介绍过，看一下方法主体：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">private </span><span style="color:#ebcb8b;">ConfigurableEnvironment </span><span style="color:#bf616a;">prepareEnvironment</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">SpringApplicationRunListeners</span><span style="color:#c0c5ce;"> listeners,
    </span><span style="color:#ebcb8b;">DefaultBootstrapContext</span><span style="color:#c0c5ce;"> bootstrapContext, </span><span style="color:#ebcb8b;">ApplicationArguments</span><span style="color:#c0c5ce;"> applicationArguments) {
  </span><span style="color:#65737e;">// Create and configure the environment
  </span><span style="color:#ebcb8b;">ConfigurableEnvironment</span><span style="color:#c0c5ce;"> environment = </span><span style="color:#bf616a;">getOrCreateEnvironment</span><span style="color:#c0c5ce;">();
  </span><span style="color:#bf616a;">configureEnvironment</span><span style="color:#c0c5ce;">(environment, applicationArguments.</span><span style="color:#bf616a;">getSourceArgs</span><span style="color:#c0c5ce;">());
  </span><span style="color:#ebcb8b;">ConfigurationPropertySources</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">attach</span><span style="color:#c0c5ce;">(environment);

  listeners.</span><span style="color:#bf616a;">environmentPrepared</span><span style="color:#c0c5ce;">(bootstrapContext, environment);

  </span><span style="color:#ebcb8b;">DefaultPropertiesPropertySource</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">moveToEnd</span><span style="color:#c0c5ce;">(environment);</span><span style="color:#65737e;">//尝试移动defaultproperties,我们这里是null,所以无操作

  </span><span style="color:#bf616a;">configureAdditionalProfiles</span><span style="color:#c0c5ce;">(environment);</span><span style="color:#65737e;">//配置additionalProfiles，这里是空的集合，所以无操作

  </span><span style="color:#bf616a;">bindToSpringApplication</span><span style="color:#c0c5ce;">(environment);

  </span><span style="color:#65737e;">// 确保enviroment类型正确
  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.isCustomEnvironment) {
    environment = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">EnvironmentConverter</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">getClassLoader</span><span style="color:#c0c5ce;">()).</span><span style="color:#bf616a;">convertEnvironmentIfNecessary</span><span style="color:#c0c5ce;">(environment,
        </span><span style="color:#bf616a;">deduceEnvironmentClass</span><span style="color:#c0c5ce;">());
  }

  </span><span style="color:#65737e;">//从上一次attach之后，enviroment中的propertysources已经发生变化，这里重新attach一次
  </span><span style="color:#ebcb8b;">ConfigurationPropertySources</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">attach</span><span style="color:#c0c5ce;">(environment);
  </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> environment;
}
</span></code></pre>
<p>先初始化一个<code>enviroment</code>对象，<code>getOrCreateEnvironment</code>会根据<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2.1.1">前面的webApplicationType</a>来获取一个初始值，我们的例子中是<code>new StandardServletEnvironment()</code>，在实例化这个对象的过程中，它会调用祖先类<code>AbstractEnvironment</code>的构造函数来执行自身的<code>customizePropertySources</code>方法，从而设置几个<code>PropertySource</code></p>
<p>然后调用<code>configureEnvironment</code>方法，这一步主要是给<code>enviroment</code>设置<code>conversionService</code>，祖先类<code>AbstractEnvironment</code>的构造函数中初始化了一个字段<code>propertyResolver</code>，类型是<code>PropertySourcesPropertyResolver</code>，<code>conversionService</code>就是设置在<code>propertyResolver</code>上的</p>
<p><code>attach</code>方法把<code>enviroment</code>里面的<code>propertysource</code>封装到<code>ConfigurationPropertySourcesPropertySource</code>内，并把封装后的元素添加到<code>propertysource</code>的第1个位置，看下面这行代码：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#c0c5ce;">sources.</span><span style="color:#bf616a;">addFirst</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ConfigurationPropertySourcesPropertySource</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">ATTACHED_PROPERTY_SOURCE_NAME</span><span style="color:#c0c5ce;">,
    </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">SpringConfigurationPropertySources</span><span style="color:#c0c5ce;">(sources)));
</span></code></pre>
<p>被封装的<code>sources</code>是一个引用对象，也就是说，当<code>sources.addFirst</code>这个操作完成后，被封装的<code>sources</code>也发生了变化，<code>sources</code>可以在自身包含的元素中看到对自身的引用，如果在调试时查看<code>source</code>内容，可以&quot;无限展开&quot;，如下图：</p>
<details>
<summary>显示图片</summary>
<p><img src="https://www.fewth.com/spring-bootqi-dong-liu-cheng/propertysource.png" alt="图片" title="循环引用的sources" /></p>
</details>
<p><code>listeners.environmentPrepared(bootstrapContext, environment);</code><span id="prepareenv">&quot;这一行</span>触发事件environmentPrepared，通知所有符合条件的监听器执行操作，spring boot的<code>application.properties</code>配置文件就是在这时候被读取并解析的，在<code>org.springframework.boot.env.PropertiesPropertySourceLoader</code>这个类的<code>load</code>方法打个断点，就能反向的看到整个过程。</p>
<p><code>bindToSpringApplication(environment);</code>把配置文件中的<code>spring.main</code>前缀的属性绑定到<code>SpringApplication</code>实例（配置文件中的信息已经在<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#prepareenv">上一步</a>操作中绑定到了enviroment变量中），比如我们在<code>application.properties</code>配置文件中设置了<code>spring.main.banner-mode=off</code>（默认值是console)，在bind这一步完成后，值就变成了off。<code>spring.main</code>对应的都是<code>SpringApplication</code>中的字段(但不是所有字段都开放修改），可以在配置文件中覆盖默认值。</p>
<h4 id="2-2-6-configureignorebeaninfo-environment">2.2.6 configureIgnoreBeanInfo(environment)</h4>
<p>设置<code>spring.beaninfo.ignore</code>这个系统变量的值，如果之前已经设置，则跳过，如果没有设置，则设为<code>true</code></p>
<h4 id="2-2-7-createapplicationcontext">2.2.7 createApplicationContext()</h4>
<p>给context赋值,根据<code>webApplicationType</code>的值返回对应的实例，我们的例子是<code>SERVLET</code>，返回<code>new AnnotationConfigServletWebServerApplicationContext()</code>，相当于一个基准容器。</p>
<blockquote>
<p>这个方法调用的是<code>ApplicationContextFactory</code>的<code>create</code>方法，而实现<code>ApplicationContextFactory</code>接口的实例<code>DEFAULT</code>是通过lambda表达式给出的。</p>
</blockquote>
<h4 id="2-2-8-context-setapplicationstartup-this-applicationstartup">2.2.8 context.setApplicationStartup(this.applicationStartup)</h4>
<p>设置<code>applicationStartup</code>这个字段，值是<code>ApplicationStartup.DEFAULT</code>，这里调用的是当前<code>context</code>的祖先类<code>GenericApplicationContext</code>里的<code>setApplicationStartup</code>方法，如下：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#c0c5ce;">@</span><span style="color:#bf616a;">Override
</span><span style="color:#b48ead;">public</span><span style="color:#c0c5ce;"> void </span><span style="color:#bf616a;">setApplicationStartup</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ApplicationStartup</span><span style="color:#c0c5ce;"> applicationStartup) {
  </span><span style="color:#bf616a;">super</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">setApplicationStartup</span><span style="color:#c0c5ce;">(applicationStartup);
  </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.beanFactory.</span><span style="color:#bf616a;">setApplicationStartup</span><span style="color:#c0c5ce;">(applicationStartup);
}
</span></code></pre>
<p>分两步，首先设置它的父类<code>AbstractApplicationContext</code>的字段<code>applicationStartup</code>，然后设置它的字段<code>beanFactory</code>内的字段<code>applicationStartup</code>，<code>beanFactory</code>的类型是<code>DefaultListableBeanFactory</code>,实际上这两处设置的字段，本身的初始化值就是<code>ApplicationStartup.DEFAULT</code>。</p>
<h4 id="2-2-9-preparecontext">2.2.9 prepareContext</h4>
<p>传入前面设置好的多个变量，给容器作调整，方法如下：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">private</span><span style="color:#c0c5ce;"> void </span><span style="color:#bf616a;">prepareContext</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">DefaultBootstrapContext</span><span style="color:#c0c5ce;"> bootstrapContext, </span><span style="color:#ebcb8b;">ConfigurableApplicationContext</span><span style="color:#c0c5ce;"> context,</span><span style="color:#ebcb8b;">ConfigurableEnvironment</span><span style="color:#c0c5ce;"> environment, </span><span style="color:#ebcb8b;">SpringApplicationRunListeners</span><span style="color:#c0c5ce;"> listeners,
</span><span style="color:#ebcb8b;">ApplicationArguments</span><span style="color:#c0c5ce;"> applicationArguments, </span><span style="color:#ebcb8b;">Banner</span><span style="color:#c0c5ce;"> printedBanner) {
  context.</span><span style="color:#bf616a;">setEnvironment</span><span style="color:#c0c5ce;">(environment);
  </span><span style="color:#bf616a;">postProcessApplicationContext</span><span style="color:#c0c5ce;">(context);
  </span><span style="color:#bf616a;">applyInitializers</span><span style="color:#c0c5ce;">(context);
  listeners.</span><span style="color:#bf616a;">contextPrepared</span><span style="color:#c0c5ce;">(context); </span><span style="color:#65737e;">// 触发contextPrepared事件，让对应的监听器处理，这里有两个监听器符合条件，但无处理操作

</span><span style="color:#c0c5ce;">  bootstrapContext.</span><span style="color:#bf616a;">close</span><span style="color:#c0c5ce;">(context); </span><span style="color:#65737e;">// 关闭bootstrapContext并触发相关事件，此处无对应监听器

  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.logStartupInfo) { </span><span style="color:#65737e;">// 是否打印启动信息
    </span><span style="color:#bf616a;">logStartupInfo</span><span style="color:#c0c5ce;">(context.</span><span style="color:#bf616a;">getParent</span><span style="color:#c0c5ce;">() == </span><span style="color:#d08770;">null</span><span style="color:#c0c5ce;">); </span><span style="color:#65737e;">// 对应启动信息里的第一行
    </span><span style="color:#bf616a;">logStartupProfileInfo</span><span style="color:#c0c5ce;">(context); </span><span style="color:#65737e;">// // 对应启动信息里的第f二行
  </span><span style="color:#c0c5ce;">}

  </span><span style="color:#65737e;">// Add boot specific singleton beans
  </span><span style="color:#ebcb8b;">ConfigurableListableBeanFactory</span><span style="color:#c0c5ce;"> beanFactory = context.</span><span style="color:#bf616a;">getBeanFactory</span><span style="color:#c0c5ce;">(); </span><span style="color:#65737e;">// 获取beanfactory，值是`new DefaultListableBeanFactory()`
</span><span style="color:#c0c5ce;">  beanFactory.</span><span style="color:#bf616a;">registerSingleton</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">springApplicationArguments</span><span style="color:#c0c5ce;">&quot;, applicationArguments); </span><span style="color:#65737e;">//注册applicationArguments

  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(printedBanner != </span><span style="color:#d08770;">null</span><span style="color:#c0c5ce;">) { </span><span style="color:#65737e;">//如果application.properties里设置了spring.main.banner-mode=off，这里就跳过
</span><span style="color:#c0c5ce;">    beanFactory.</span><span style="color:#bf616a;">registerSingleton</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">springBootBanner</span><span style="color:#c0c5ce;">&quot;, printedBanner); </span><span style="color:#65737e;">// 注册Banner
  </span><span style="color:#c0c5ce;">}

  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(beanFactory instanceof </span><span style="color:#ebcb8b;">DefaultListableBeanFactory</span><span style="color:#c0c5ce;">) { </span><span style="color:#65737e;">// true

    // 给beanFactory设置是否允许BeanDefinitionOverriding,值是false
    </span><span style="color:#c0c5ce;">((</span><span style="color:#ebcb8b;">DefaultListableBeanFactory</span><span style="color:#c0c5ce;">) beanFactory)
        .</span><span style="color:#bf616a;">setAllowBeanDefinitionOverriding</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.allowBeanDefinitionOverriding);
  }
  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.lazyInitialization) { </span><span style="color:#65737e;">// false
</span><span style="color:#c0c5ce;">    context.</span><span style="color:#bf616a;">addBeanFactoryPostProcessor</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LazyInitializationBeanFactoryPostProcessor</span><span style="color:#c0c5ce;">());
  }
  </span><span style="color:#65737e;">// Load the sources
  </span><span style="color:#ebcb8b;">Set</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">Object</span><span style="color:#c0c5ce;">&gt; sources = </span><span style="color:#bf616a;">getAllSources</span><span style="color:#c0c5ce;">();
  </span><span style="color:#ebcb8b;">Assert</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">notEmpty</span><span style="color:#c0c5ce;">(sources, &quot;</span><span style="color:#a3be8c;">Sources must not be empty</span><span style="color:#c0c5ce;">&quot;); </span><span style="color:#65737e;">// 检查sources不为空
  </span><span style="color:#bf616a;">load</span><span style="color:#c0c5ce;">(context, sources.</span><span style="color:#bf616a;">toArray</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Object</span><span style="color:#c0c5ce;">[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">])); 
  listeners.</span><span style="color:#bf616a;">contextLoaded</span><span style="color:#c0c5ce;">(context); 
}
</span></code></pre>
<ul>
<li>
<p><code>context.setEnvironment(environment)</code>：把环境变量设置到context的对应字段上，分别是其祖先类<code>AbstractApplication</code>的<code>enviroment</code>字段，及<code>reader</code>和<code>scanner</code>的相关字段</p>
</li>
<li>
<p><code>postProcessApplicationContext(context)</code>：对<code>context</code>作一些补充设置，判断<code>beanNameGenerator</code>，<code>resourceLoader</code>，<code>addConversionService</code>这3个字段是否被设置，如果是，则对<code>context</code>作相应的设置，这里前面2个都是Null，第3个设置到<code>context</code>的祖先类<code>AbstractBeanFactory</code>的字段上</p>
</li>
<li>
<p><code>applyInitializers(context)</code>:用<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2.1.3">2.1.3</a>设置的<code>initializer</code>挨个对<code>context</code>执行初始化。</p>
</li>
<li>
<p><code>Set&lt;Object&gt; sources = getAllSources()</code>：获取<code>this.primarySource</code>(见<a href="https://www.fewth.com/spring-bootqi-dong-liu-cheng/#2.1">2.1</a>,值是<code>com.example.demo.DemoApplication.class</code>)和<code>this.sources</code>的值（空集合）</p>
</li>
<li>
<p><code>load(context, sources.toArray(new Object[0]))</code>:把主启动类注册到<code>context</code></p>
</li>
<li>
<p><code>listeners.contextLoaded(context)</code>：发出contextLoaded事件，在EventPublishingRunListener中用ApplicationPreparedEvent包装。主要是<code>LoggingApplicationListener</code>注册了两个<code>log</code>相关的<code>singletonbean</code>，及<code>EnvironmentPostProcessorApplicationListener</code>对<code>log</code>进行一些处理。</p>
</li>
</ul>
<h4 id="2-2-10-refreshcontext">2.2.10 refreshContext</h4>
<p>首先确保<code>registerShutdownHook</code>存在，不存在的话创建一个。这个勾子函数的作用是在JVM关闭的时候，先关闭context，但是如果JVM是非正常退出，比如被系统中止进程，内存访问出错等，那勾子函数不一定生效。</p>
<p>实现的方法在<code>AbstractApplicationContext</code>的<code>refresh</code>，如下：</p>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#c0c5ce;">@</span><span style="color:#bf616a;">Override
</span><span style="color:#b48ead;">public</span><span style="color:#c0c5ce;"> void </span><span style="color:#bf616a;">refresh</span><span style="color:#c0c5ce;">() throws </span><span style="color:#ebcb8b;">BeansException</span><span style="color:#c0c5ce;">, </span><span style="color:#ebcb8b;">IllegalStateException </span><span style="color:#c0c5ce;">{
  </span><span style="color:#b48ead;">synchronized </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.startupShutdownMonitor) {
    </span><span style="color:#ebcb8b;">StartupStep</span><span style="color:#c0c5ce;"> contextRefresh = </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.applicationStartup.</span><span style="color:#bf616a;">start</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">spring.context.refresh</span><span style="color:#c0c5ce;">&quot;);

    </span><span style="color:#65737e;">// Prepare this context for refreshing.
    </span><span style="color:#bf616a;">prepareRefresh</span><span style="color:#c0c5ce;">(); </span><span style="color:#65737e;">// 初始化一些属性，判断this.earlyApplicationListeners是否有值，有的话把这些值传入this.applicationListeners（先清空），如果没有，则反过来，把this.applicationListeners的值传给this.earlyApplicationListeners

    // Tell the subclass to refresh the internal bean factory.
    </span><span style="color:#ebcb8b;">ConfigurableListableBeanFactory</span><span style="color:#c0c5ce;"> beanFactory = </span><span style="color:#bf616a;">obtainFreshBeanFactory</span><span style="color:#c0c5ce;">(); </span><span style="color:#65737e;">// 获取beanFactory,类型是DefaultListableBeanFactory，设置了serializableId=application

    // Prepare the bean factory for use in this context.
    </span><span style="color:#bf616a;">prepareBeanFactory</span><span style="color:#c0c5ce;">(beanFactory);

    </span><span style="color:#b48ead;">try </span><span style="color:#c0c5ce;">{

      </span><span style="color:#65737e;">// 添加一个WebApplicationContextServletContextAwareProcessor类型的postProcessor，及把ServletContextAware.class接口添加到ignoreDependencyInterface列表内
      // Allows post-processing of the bean factory in context subclasses.
      </span><span style="color:#bf616a;">postProcessBeanFactory</span><span style="color:#c0c5ce;">(beanFactory);

      </span><span style="color:#65737e;">// 启动一个步骤，步骤可以记录它开始到结束的数据，或者步骤耗时等，这里用处不大
      </span><span style="color:#ebcb8b;">StartupStep</span><span style="color:#c0c5ce;"> beanPostProcess = </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">.applicationStartup.</span><span style="color:#bf616a;">start</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">spring.context.beans.post-process</span><span style="color:#c0c5ce;">&quot;);
      
      </span><span style="color:#65737e;">// Invoke factory processors registered as beans in the context.
      </span><span style="color:#bf616a;">invokeBeanFactoryPostProcessors</span><span style="color:#c0c5ce;">(beanFactory);

      </span><span style="color:#65737e;">// Register bean processors that intercept bean creation.
      </span><span style="color:#bf616a;">registerBeanPostProcessors</span><span style="color:#c0c5ce;">(beanFactory);
      </span><span style="color:#65737e;">// 结束步骤
</span><span style="color:#c0c5ce;">      beanPostProcess.</span><span style="color:#bf616a;">end</span><span style="color:#c0c5ce;">();

      </span><span style="color:#65737e;">// Initialize message source for this context.
      // 初始化MessageSource,这里是空，并且步骤中会记录trace级别的log，如果在application.properties中开启的话，就可以看到
      </span><span style="color:#bf616a;">initMessageSource</span><span style="color:#c0c5ce;">();

      </span><span style="color:#65737e;">// Initialize event multicaster for this context.
      // 初始化applicationEventMulticaster属性，示例中用的是SimpleApplicationEventMulticaster类型
      </span><span style="color:#bf616a;">initApplicationEventMulticaster</span><span style="color:#c0c5ce;">();

      </span><span style="color:#65737e;">// Initialize other special beans in specific context subclasses.
      // 启动内嵌的tomcat容器，console输出相关5条INFO级别信息
      </span><span style="color:#bf616a;">onRefresh</span><span style="color:#c0c5ce;">();

      </span><span style="color:#65737e;">// Check for listener beans and register them.
      // 找到context中直接存在的listener以及bean中属于ApplicationListener类型的bean，注册到ApplicationEventMulticaster中(示例实现类是SimpleApplicationEventMulticaster)
      </span><span style="color:#bf616a;">registerListeners</span><span style="color:#c0c5ce;">();

      </span><span style="color:#65737e;">// Instantiate all remaining (non-lazy-init) singletons.
      </span><span style="color:#bf616a;">finishBeanFactoryInitialization</span><span style="color:#c0c5ce;">(beanFactory);

      </span><span style="color:#65737e;">// Last step: publish corresponding event.
      </span><span style="color:#bf616a;">finishRefresh</span><span style="color:#c0c5ce;">();
    }

    </span><span style="color:#b48ead;">catch </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">BeansException </span><span style="color:#bf616a;">ex</span><span style="color:#c0c5ce;">) {
      </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(logger.</span><span style="color:#bf616a;">isWarnEnabled</span><span style="color:#c0c5ce;">()) {
        logger.</span><span style="color:#bf616a;">warn</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">Exception encountered during context initialization - </span><span style="color:#c0c5ce;">&quot; +
            &quot;</span><span style="color:#a3be8c;">cancelling refresh attempt: </span><span style="color:#c0c5ce;">&quot; + ex);
      }

      </span><span style="color:#65737e;">// Destroy already created singletons to avoid dangling resources.
      </span><span style="color:#bf616a;">destroyBeans</span><span style="color:#c0c5ce;">();

      </span><span style="color:#65737e;">// Reset &#39;active&#39; flag.
      </span><span style="color:#bf616a;">cancelRefresh</span><span style="color:#c0c5ce;">(ex);

      </span><span style="color:#65737e;">// Propagate exception to caller.
      </span><span style="color:#b48ead;">throw</span><span style="color:#c0c5ce;"> ex;
    }

    </span><span style="color:#b48ead;">finally </span><span style="color:#c0c5ce;">{
      </span><span style="color:#65737e;">// Reset common introspection caches in Spring&#39;s core, since we
      // might not ever need metadata for singleton beans anymore...
      </span><span style="color:#bf616a;">resetCommonCaches</span><span style="color:#c0c5ce;">();
      contextRefresh.</span><span style="color:#bf616a;">end</span><span style="color:#c0c5ce;">();
    }
  }
}
</span></code></pre>
<ul>
<li><code>prepareBeanFactory</code>:对<code>beanFactory</code>进行各种设置，方法如下，用注释说明。</li>
</ul>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">protected</span><span style="color:#c0c5ce;"> void </span><span style="color:#bf616a;">prepareBeanFactory</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ConfigurableListableBeanFactory</span><span style="color:#c0c5ce;"> beanFactory) {
  </span><span style="color:#65737e;">// Tell the internal bean factory to use the context&#39;s class loader etc.
</span><span style="color:#c0c5ce;">  beanFactory.</span><span style="color:#bf616a;">setBeanClassLoader</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">getClassLoader</span><span style="color:#c0c5ce;">());

  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!shouldIgnoreSpel) { </span><span style="color:#65737e;">// 是否忽略SpEL(Spring Expression Language)，这里是不忽略，所以设置相应的解析器
</span><span style="color:#c0c5ce;">    beanFactory.</span><span style="color:#bf616a;">setBeanExpressionResolver</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">StandardBeanExpressionResolver</span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">getBeanClassLoader</span><span style="color:#c0c5ce;">()));
  }

  </span><span style="color:#65737e;">// 添加一个propertyEditor的注册器，用来注册各种editor
</span><span style="color:#c0c5ce;">  beanFactory.</span><span style="color:#bf616a;">addPropertyEditorRegistrar</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ResourceEditorRegistrar</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">getEnvironment</span><span style="color:#c0c5ce;">()));

  </span><span style="color:#65737e;">// Configure the bean factory with context callbacks.
</span><span style="color:#c0c5ce;">  beanFactory.</span><span style="color:#bf616a;">addBeanPostProcessor</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ApplicationContextAwareProcessor</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">)); </span><span style="color:#65737e;">// 添加一个beanPostProcessor，类型是ApplicationContextAwareProcessor，如果原先存在，则先删除再添加，添加在AbstractBeanFactory的beanPostProcessors属性上

  // 添加下面的几个类到ignoredDependencyInterfaces属性（从DefaultListableBeanFactory的父类AbstractAutowireCapableBeanFactory中继承），后面的一些操作会根据这个set属性中的接口来判断是否要过滤相应的属性（判断属性的setter方法是否源于实现相应的接口方法）
  // BeanFactoryAware.class是默认添加的
</span><span style="color:#c0c5ce;">  beanFactory.</span><span style="color:#bf616a;">ignoreDependencyInterface</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">EnvironmentAware</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">);
  beanFactory.</span><span style="color:#bf616a;">ignoreDependencyInterface</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">EmbeddedValueResolverAware</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">);
  beanFactory.</span><span style="color:#bf616a;">ignoreDependencyInterface</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ResourceLoaderAware</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">);
  beanFactory.</span><span style="color:#bf616a;">ignoreDependencyInterface</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ApplicationEventPublisherAware</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">);
  beanFactory.</span><span style="color:#bf616a;">ignoreDependencyInterface</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">MessageSourceAware</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">);
  beanFactory.</span><span style="color:#bf616a;">ignoreDependencyInterface</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ApplicationContextAware</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">);
  beanFactory.</span><span style="color:#bf616a;">ignoreDependencyInterface</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ApplicationStartupAware</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">);

  </span><span style="color:#65737e;">// 这一步类似于手动装配，第1个参数是类型，第2个参数是这个类型返回的实例，如果第2个参数实现了第1个参数的子接口，那么这个子接口也会被装配
  // BeanFactory interface not registered as resolvable type in a plain factory.
  // MessageSource registered (and found for autowiring) as a bean.
</span><span style="color:#c0c5ce;">  beanFactory.</span><span style="color:#bf616a;">registerResolvableDependency</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">BeanFactory</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, beanFactory);
  beanFactory.</span><span style="color:#bf616a;">registerResolvableDependency</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ResourceLoader</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">);
  beanFactory.</span><span style="color:#bf616a;">registerResolvableDependency</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ApplicationEventPublisher</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">);
  beanFactory.</span><span style="color:#bf616a;">registerResolvableDependency</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">ApplicationContext</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">);

  </span><span style="color:#65737e;">// 添加一个针对ApplictionListener后处器
  // Register early post-processor for detecting inner beans as ApplicationListeners.
</span><span style="color:#c0c5ce;">  beanFactory.</span><span style="color:#bf616a;">addBeanPostProcessor</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ApplicationListenerDetector</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">this</span><span style="color:#c0c5ce;">));

  </span><span style="color:#65737e;">// 跳过，loadTimeWeaver在JVM加载类之前通过transformer对类其进行处理，这里没有这个bean
  // Detect a LoadTimeWeaver and prepare for weaving, if found.
  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!</span><span style="color:#ebcb8b;">NativeDetector</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">inNativeImage</span><span style="color:#c0c5ce;">() &amp;&amp; beanFactory.</span><span style="color:#bf616a;">containsBean</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">LOAD_TIME_WEAVER_BEAN_NAME</span><span style="color:#c0c5ce;">)) {
    beanFactory.</span><span style="color:#bf616a;">addBeanPostProcessor</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LoadTimeWeaverAwareProcessor</span><span style="color:#c0c5ce;">(beanFactory));
    </span><span style="color:#65737e;">// Set a temporary ClassLoader for type matching.
</span><span style="color:#c0c5ce;">    beanFactory.</span><span style="color:#bf616a;">setTempClassLoader</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ContextTypeMatchClassLoader</span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">getBeanClassLoader</span><span style="color:#c0c5ce;">()));
  }

  </span><span style="color:#65737e;">// 确保下面几个类型的bean都注册了，如果没注册，就设置为当前context相关的实例
  // Register default environment beans.
  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!beanFactory.</span><span style="color:#bf616a;">containsLocalBean</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">ENVIRONMENT_BEAN_NAME</span><span style="color:#c0c5ce;">)) {
    beanFactory.</span><span style="color:#bf616a;">registerSingleton</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">ENVIRONMENT_BEAN_NAME</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">getEnvironment</span><span style="color:#c0c5ce;">());
  }
  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!beanFactory.</span><span style="color:#bf616a;">containsLocalBean</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">SYSTEM_PROPERTIES_BEAN_NAME</span><span style="color:#c0c5ce;">)) {
    beanFactory.</span><span style="color:#bf616a;">registerSingleton</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">SYSTEM_PROPERTIES_BEAN_NAME</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">getEnvironment</span><span style="color:#c0c5ce;">().</span><span style="color:#bf616a;">getSystemProperties</span><span style="color:#c0c5ce;">());
  }
  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!beanFactory.</span><span style="color:#bf616a;">containsLocalBean</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">SYSTEM_ENVIRONMENT_BEAN_NAME</span><span style="color:#c0c5ce;">)) {
    beanFactory.</span><span style="color:#bf616a;">registerSingleton</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">SYSTEM_ENVIRONMENT_BEAN_NAME</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">getEnvironment</span><span style="color:#c0c5ce;">().</span><span style="color:#bf616a;">getSystemEnvironment</span><span style="color:#c0c5ce;">());
  }
  </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!beanFactory.</span><span style="color:#bf616a;">containsLocalBean</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">APPLICATION_STARTUP_BEAN_NAME</span><span style="color:#c0c5ce;">)) {
    beanFactory.</span><span style="color:#bf616a;">registerSingleton</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">APPLICATION_STARTUP_BEAN_NAME</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">getApplicationStartup</span><span style="color:#c0c5ce;">());
  }
}
</span></code></pre>
<ul>
<li>invokeBeanFactoryPostProcessors(beanFactory):从<code>context</code>中获取<code>beanFactoryPostProcessors</code>对当前的<code>beanFactory</code>进行处理，实现这个功能的方法是<code>PostProcessorRegistrationDelegate</code>的<code>invokeBeanFactoryPostProcessors</code>，方法内容很多，方法中涉及的内容只用注释说明，不再继续展开，方法如下：</li>
</ul>
<details>
<summary>展开内容</summary>
<pre style="background-color:#2b303b;">
<code class="language-java" data-lang="java"><span style="color:#b48ead;">public static</span><span style="color:#c0c5ce;"> void </span><span style="color:#bf616a;">invokeBeanFactoryPostProcessors</span><span style="color:#c0c5ce;">(
			</span><span style="color:#ebcb8b;">ConfigurableListableBeanFactory</span><span style="color:#c0c5ce;"> beanFactory, </span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;">&gt; beanFactoryPostProcessors) {

		</span><span style="color:#65737e;">// Invoke BeanDefinitionRegistryPostProcessors first, if any.
		</span><span style="color:#ebcb8b;">Set</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;">&gt; processedBeans = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">HashSet</span><span style="color:#c0c5ce;">&lt;&gt;();

		</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(beanFactory instanceof </span><span style="color:#ebcb8b;">BeanDefinitionRegistry</span><span style="color:#c0c5ce;">) {
			</span><span style="color:#ebcb8b;">BeanDefinitionRegistry</span><span style="color:#c0c5ce;"> registry = (</span><span style="color:#ebcb8b;">BeanDefinitionRegistry</span><span style="color:#c0c5ce;">) beanFactory;
			</span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;">&gt; regularPostProcessors = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;&gt;();
			</span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">&gt; registryProcessors = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;&gt;();

     </span><span style="color:#65737e;">// 先对beanFactory这个bean自身的definition的注册进行处理
     // 在我们的例子中有两个`beanFactoryPostProcessor`,都是嵌套类，分别是
     // `SharedMetadataReaderFactoryContextInitializer.CachingMetadataReaderFactoryPostProcessor`
     // 和`ConfigurationWarningsApplicationContextInitializer.ComponentScanPackageCheck`,
     // 第1个给名字为`org.springframework.context.annotation.internalConfigurationAnnotationProcessor`
     // 的`beanDefination`(对应的`Class`是`ConfigurationClassPostProcessor`)添加一个`propertyValue`，键值对是`metadataReaderFactory`：
     // `&lt;org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory&gt;`。
     // 第2个扫描所有的`beanDefinition`，判断`@ComponentScan`注解是否可以正常运行。
			</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;"> postProcessor : beanFactoryPostProcessors) {
        </span><span style="color:#65737e;">// 这一步两个都是
				</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(postProcessor instanceof </span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">) {
					</span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;"> registryProcessor =
							(</span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">) postProcessor;
					registryProcessor.</span><span style="color:#bf616a;">postProcessBeanDefinitionRegistry</span><span style="color:#c0c5ce;">(registry);
					registryProcessors.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(registryProcessor);
				}
				</span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
					regularPostProcessors.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(postProcessor);
				}
			}

			</span><span style="color:#65737e;">// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the bean factory post-processors apply to them!
			// Separate between BeanDefinitionRegistryPostProcessors that implement
			// PriorityOrdered, Ordered, and the rest.
			</span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">&gt; currentRegistryProcessors = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;&gt;();

			</span><span style="color:#65737e;">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      // 先调用实现了PriorityOrdered接口的处理器
      // 从beanFactory中获取处理bean注册的类的beanName，本例中只有1个：org.springframework.context.annotation.internalConfigurationAnnotationProcessor,对应ConfigurationClassPostProcessor
			</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[]</span><span style="color:#c0c5ce;"> postProcessorNames =
					beanFactory.</span><span style="color:#bf616a;">getBeanNamesForType</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">);
      </span><span style="color:#65737e;">// 只添加实现了PriorityOrdered接口的postProcessor
			</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;"> ppName : postProcessorNames) {
				</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">isTypeMatch</span><span style="color:#c0c5ce;">(ppName, </span><span style="color:#ebcb8b;">PriorityOrdered</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">)) {
					currentRegistryProcessors.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">getBean</span><span style="color:#c0c5ce;">(ppName, </span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">));
					processedBeans.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(ppName);
				}
			}
      </span><span style="color:#65737e;">// 排序
			</span><span style="color:#bf616a;">sortPostProcessors</span><span style="color:#c0c5ce;">(currentRegistryProcessors, beanFactory);
      </span><span style="color:#65737e;">// 添加registryProcessors中，加上第1步的2个，总共3个
</span><span style="color:#c0c5ce;">			registryProcessors.</span><span style="color:#bf616a;">addAll</span><span style="color:#c0c5ce;">(currentRegistryProcessors);
      </span><span style="color:#65737e;">// 这一步对已经注册的bean进行处理，包括主启动类demo，解析它的@SpringbootApplication注解，并解析其子注解，是Springboot注解驱动的重要实现,示例中的130多个bean在这里被注册
			</span><span style="color:#bf616a;">invokeBeanDefinitionRegistryPostProcessors</span><span style="color:#c0c5ce;">(currentRegistryProcessors, registry, beanFactory.</span><span style="color:#bf616a;">getApplicationStartup</span><span style="color:#c0c5ce;">());
			currentRegistryProcessors.</span><span style="color:#bf616a;">clear</span><span style="color:#c0c5ce;">(); </span><span style="color:#65737e;">// 清空列表

			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      // 在调用了实现Priority接口的处理器后，接着调用实现了Ordered接口的处理器
      //这里获取到org.springframework.context.annotation.internalConfigurationAnnotationProcessorp这个名字，不过在前面的for循环中已经被处理过，所以跳过了
</span><span style="color:#c0c5ce;">			postProcessorNames = beanFactory.</span><span style="color:#bf616a;">getBeanNamesForType</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">);
			</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;"> ppName : postProcessorNames) {
				</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!processedBeans.</span><span style="color:#bf616a;">contains</span><span style="color:#c0c5ce;">(ppName) &amp;&amp; beanFactory.</span><span style="color:#bf616a;">isTypeMatch</span><span style="color:#c0c5ce;">(ppName, </span><span style="color:#ebcb8b;">Ordered</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">)) {
					currentRegistryProcessors.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">getBean</span><span style="color:#c0c5ce;">(ppName, </span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">));
					processedBeans.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(ppName);
				}
			}
      </span><span style="color:#65737e;">// currentRegistryProcessors已经被清空，所以下面几步都没有实际作
			</span><span style="color:#bf616a;">sortPostProcessors</span><span style="color:#c0c5ce;">(currentRegistryProcessors, beanFactory);
			registryProcessors.</span><span style="color:#bf616a;">addAll</span><span style="color:#c0c5ce;">(currentRegistryProcessors);
			</span><span style="color:#bf616a;">invokeBeanDefinitionRegistryPostProcessors</span><span style="color:#c0c5ce;">(currentRegistryProcessors, registry, beanFactory.</span><span style="color:#bf616a;">getApplicationStartup</span><span style="color:#c0c5ce;">());
			currentRegistryProcessors.</span><span style="color:#bf616a;">clear</span><span style="color:#c0c5ce;">();

			</span><span style="color:#65737e;">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      // while循环的内容跟上面是一样的，现在处理剩下的没有实现PriorityOrdered和Ordered接口的bean,也只有internalConfigurationAnnotationProcessorp这个在processedBeans中已经存在的bean，所以while循环内也没有实际操作
			</span><span style="color:#b48ead;">boolean</span><span style="color:#c0c5ce;"> reiterate = </span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">;
			</span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(reiterate) {
				reiterate = </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">;
				postProcessorNames = beanFactory.</span><span style="color:#bf616a;">getBeanNamesForType</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">);
				</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;"> ppName : postProcessorNames) {
					</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(!processedBeans.</span><span style="color:#bf616a;">contains</span><span style="color:#c0c5ce;">(ppName)) {
						currentRegistryProcessors.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">getBean</span><span style="color:#c0c5ce;">(ppName, </span><span style="color:#ebcb8b;">BeanDefinitionRegistryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">));
						processedBeans.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(ppName);
						reiterate = </span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">;
					}
				}
				</span><span style="color:#bf616a;">sortPostProcessors</span><span style="color:#c0c5ce;">(currentRegistryProcessors, beanFactory);
				registryProcessors.</span><span style="color:#bf616a;">addAll</span><span style="color:#c0c5ce;">(currentRegistryProcessors);
				</span><span style="color:#bf616a;">invokeBeanDefinitionRegistryPostProcessors</span><span style="color:#c0c5ce;">(currentRegistryProcessors, registry, beanFactory.</span><span style="color:#bf616a;">getApplicationStartup</span><span style="color:#c0c5ce;">());
				currentRegistryProcessors.</span><span style="color:#bf616a;">clear</span><span style="color:#c0c5ce;">();
			}

			</span><span style="color:#65737e;">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
      // 调用registryProcessors中的后处理器去处理beanFactory中的所有bean,这里有效处理器只有ConfigurationClassPostProcessor这一个，遍历的bean有130多个
			</span><span style="color:#bf616a;">invokeBeanFactoryPostProcessors</span><span style="color:#c0c5ce;">(registryProcessors, beanFactory);.
      </span><span style="color:#65737e;">// 参数1是空，所以跳过
			</span><span style="color:#bf616a;">invokeBeanFactoryPostProcessors</span><span style="color:#c0c5ce;">(regularPostProcessors, beanFactory);
		}

		</span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
			</span><span style="color:#65737e;">// Invoke factory processors registered with the context instance.
			</span><span style="color:#bf616a;">invokeBeanFactoryPostProcessors</span><span style="color:#c0c5ce;">(beanFactoryPostProcessors, beanFactory);
		}



    </span><span style="color:#65737e;">// 从当前的beanFactory取出所有BeanFactoryPostProcessor类型的bean，然后按照上面一样的流程，先分3类：PriorityOrdered，Ordered，nonOrdered3类，再按照这个顺序依次处理
		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let the bean factory post-processors apply to them!
		</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[]</span><span style="color:#c0c5ce;"> postProcessorNames =
				beanFactory.</span><span style="color:#bf616a;">getBeanNamesForType</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">);

		</span><span style="color:#65737e;">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		</span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;">&gt; priorityOrderedPostProcessors = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;&gt;();
		</span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;">&gt; orderedPostProcessorNames = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;&gt;();
		</span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;">&gt; nonOrderedPostProcessorNames = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;&gt;();
		</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;"> ppName : postProcessorNames) {
			</span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(processedBeans.</span><span style="color:#bf616a;">contains</span><span style="color:#c0c5ce;">(ppName)) {
				</span><span style="color:#65737e;">// skip - already processed in first phase above
			</span><span style="color:#c0c5ce;">}
			</span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">isTypeMatch</span><span style="color:#c0c5ce;">(ppName, </span><span style="color:#ebcb8b;">PriorityOrdered</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">)) {
				priorityOrderedPostProcessors.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">getBean</span><span style="color:#c0c5ce;">(ppName, </span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">));
			}
			</span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">isTypeMatch</span><span style="color:#c0c5ce;">(ppName, </span><span style="color:#ebcb8b;">Ordered</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">)) {
				orderedPostProcessorNames.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(ppName);
			}
			</span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
				nonOrderedPostProcessorNames.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(ppName);
			}
		}

		</span><span style="color:#65737e;">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
		</span><span style="color:#bf616a;">sortPostProcessors</span><span style="color:#c0c5ce;">(priorityOrderedPostProcessors, beanFactory);
		</span><span style="color:#bf616a;">invokeBeanFactoryPostProcessors</span><span style="color:#c0c5ce;">(priorityOrderedPostProcessors, beanFactory);

		</span><span style="color:#65737e;">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
		</span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;">&gt; orderedPostProcessors = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;&gt;(orderedPostProcessorNames.</span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">());
		</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;"> postProcessorName : orderedPostProcessorNames) {
			orderedPostProcessors.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">getBean</span><span style="color:#c0c5ce;">(postProcessorName, </span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">));
		}
		</span><span style="color:#bf616a;">sortPostProcessors</span><span style="color:#c0c5ce;">(orderedPostProcessors, beanFactory);
		</span><span style="color:#bf616a;">invokeBeanFactoryPostProcessors</span><span style="color:#c0c5ce;">(orderedPostProcessors, beanFactory);

		</span><span style="color:#65737e;">// Finally, invoke all other BeanFactoryPostProcessors.
		</span><span style="color:#ebcb8b;">List</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;">&gt; nonOrderedPostProcessors = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#c0c5ce;">&lt;&gt;(nonOrderedPostProcessorNames.</span><span style="color:#bf616a;">size</span><span style="color:#c0c5ce;">());
		</span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;"> postProcessorName : nonOrderedPostProcessorNames) {
			nonOrderedPostProcessors.</span><span style="color:#bf616a;">add</span><span style="color:#c0c5ce;">(beanFactory.</span><span style="color:#bf616a;">getBean</span><span style="color:#c0c5ce;">(postProcessorName, </span><span style="color:#ebcb8b;">BeanFactoryPostProcessor</span><span style="color:#c0c5ce;">.</span><span style="color:#bf616a;">class</span><span style="color:#c0c5ce;">));
		}
		</span><span style="color:#bf616a;">invokeBeanFactoryPostProcessors</span><span style="color:#c0c5ce;">(nonOrderedPostProcessors, beanFactory);

		</span><span style="color:#65737e;">// Clear cached merged bean definitions since the post-processors might have
		// modified the original metadata, e.g. replacing placeholders in values...
</span><span style="color:#c0c5ce;">		beanFactory.</span><span style="color:#bf616a;">clearMetadataCache</span><span style="color:#c0c5ce;">();
	}
</span></code></pre></details>
<ul>
<li>
<p><code>registerBeanPostProcessors</code>：注册<code>beanPostProcessors</code>，先从<code>beanFactory</code>中获取<code>BeanPostProcessor</code>类型的相关信息，再生成对应的<code>bean</code>，最后注册到<code>beanFactory</code>的<code>beanPostProcessors</code>这个字段中。</p>
</li>
<li>
<p><code>finishBeanFactoryInitialization</code>：把<code>beanNames</code>里面所有还没有生成的bean全部生成，注册到<code>singletonObjects</code>并在<code>registeredSingletons</code>中添加名称，如果<code>bean</code>实现了<code>SmartInitializingSingleton</code>接口，则再调用其<code>afterSingletonsInstantiated</code>方法对<code>bean</code>进行一些额外的处理。在这一步控制台输出一条跟<code>ExecutorService</code>有关的信息。</p>
</li>
<li>
<p><code>finishRefresh</code>：释放一些资源，初始化跟<code>LifeCycle</code>有关的处理器(示例中是default的处理器)，然后调用这个处理器的<code>onRefresh</code>方法，这里启动了<code>Tomcat</code>，可以在控制台看到相关信息。接着发布了<code>ContextRefreshedEvent</code>类型的事件，去触发相应的操作。</p>
</li>
</ul>
<h2 id="3-zong-jie">3 总结</h2>
<p>spring boot框架非常庞大，本文只是简单的跟着<code>run</code>方法走了一遍启动流程，源码中的一些实现细节也没法全部展开，可以在需要的时候打断点分析，而且示例中没有包含<code>AOP</code>的内容，所以后续流程中也没有涉及。<br />
总的来说，整个启动流程就是为了配置好<code>context</code>这个容器，其中包含了大量的监听器和事件的内容，在特定的步骤通过分发阶段性事件的方式来启动相应的工作。</p>

    </div>

    
    

    <div class="post-footer">
        
            
            
                <div class="post-nav">
                    
                        <a class="previous" href="https:&#x2F;&#x2F;www.fewth.com&#x2F;luayu-yan-ru-men&#x2F;">‹ Lua语言入门</a>
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;www.fewth.com&#x2F;jvmzhi-yun-xing-shi-shu-ju-qu-yu&#x2F;">JVM之运行时数据区域 ›</a>
                    
                    
                    
                </div>
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https:&#x2F;&#x2F;www.fewth.com&#x2F;even.js" ></script>
      
    </body>

</html>
