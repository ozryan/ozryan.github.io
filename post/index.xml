<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on A few thoughts</title><link>https://www.fewth.com/post/</link><description>Recent content in Posts on A few thoughts</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 24 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.fewth.com/post/index.xml" rel="self" type="application/rss+xml"/><item><title>tcp如何实现可靠的传输</title><link>https://www.fewth.com/tcp%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BC%A0%E8%BE%93/</link><pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.fewth.com/tcp%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BC%A0%E8%BE%93/</guid><description>TCP属于传输层协议，传输层的数据段是封装在网络层的IP数据包内传输的，而网络层传输并不可靠，比如可能会出现丢包情况，并且每个IP数据包在路</description></item><item><title>网络分层模型</title><link>https://www.fewth.com/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</link><pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.fewth.com/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</guid><description>网络分层模型中比较常见的是TCP/IP 四层模型和OSI 七层模型，我们先介绍TCP/IP 四层模型，再用比较的方式介绍OSI 七层模型，至于其它的</description></item><item><title>第k个顺序统计量-数组中第k小的元素</title><link>https://www.fewth.com/%E7%AC%ACk%E4%B8%AA%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</link><pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.fewth.com/%E7%AC%ACk%E4%B8%AA%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</guid><description>&lt;p>要从一个数组中找出第k小的元素，最容易想到的是快速排序，但是快速排序解决这个问题有很多不必要的操作，在快速排序中，根据“哨兵”元素把数组分成两部分，然后对两部分进行递归处理，第k个顺序统计量的算法也借鉴这种思路，我们称为“快速选择(quick select)算法”,但是快速选择算法每次只需要处理第K个元素所在的那一部分就行，我们的目的只是找到目标元素，随着递归次数的深入，快速选择算法要处理的元素会越来越少（而快速排序随着递归的深入，每次递归处理的元素总数依然是n），这种差别是很大的，后面分析时间复杂度时可以得知快速选择算法的期望运行时间是$\theta(n)$。&lt;/p>
&lt;h2 id="算法实现">算法实现&lt;/h2>
&lt;p>快速选择算法跟快速排序类似，主要步骤就是分组算法：根据哨兵元素把数组分成两组，一组小于哨兵，一组大于哨兵，然后进行递归调用。&lt;/p></description></item><item><title>shell编程</title><link>https://www.fewth.com/shell%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 18 Oct 2021 15:00:33 +0000</pubDate><guid>https://www.fewth.com/shell%E7%BC%96%E7%A8%8B/</guid><description>&lt;h2 id="1-基本概念">1 基本概念&lt;/h2>
&lt;ul>
&lt;li>shell是用户和内核之间的桥梁，shell自带的叫内置命令，其它应用程序的命令叫外部命令&lt;/li>
&lt;li>shell是一种脚本语言，支持基本的编程元素，如数组，变量，字符串，注释，四则运算，逻辑运算，if-else,for,case-in,until等&lt;/li>
&lt;/ul></description></item><item><title>jvm之自动内存管理-垃圾回收机制</title><link>https://www.fewth.com/jvm%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 11 Oct 2021 16:51:51 +0000</pubDate><guid>https://www.fewth.com/jvm%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid><description>&lt;p>自动内存管理主要作用在&lt;code>堆(heap)&lt;/code>上，而虚拟机规范并没有限定自动内存管理的实现方式，本文以时下流行的&lt;code>HotSpot&lt;/code>虚拟机为例，介绍其中的自动内存管理（主要是垃圾回收）机制，以及它提供的几款垃圾回收器（Garbage Collector,简称GC）。&lt;/p></description></item><item><title>jvm之运行时数据区域</title><link>https://www.fewth.com/jvm%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</link><pubDate>Sun, 15 Aug 2021 13:48:20 +0000</pubDate><guid>https://www.fewth.com/jvm%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</guid><description>&lt;p>&lt;a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5">Java11虚拟机规范&lt;/a>中描述的，当执行一个程序时需要用到的几个运行时数据区域，具体的虚拟机实现可能并没有严格按照这个划分。&lt;/p></description></item><item><title>spring boot启动流程</title><link>https://www.fewth.com/spring-boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 14 Aug 2021 17:08:12 +0000</pubDate><guid>https://www.fewth.com/spring-boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>&lt;p>本文用一个空的&lt;code>Spring Boot&lt;/code>项目演示，从&lt;code>main&lt;/code>方法开始顺着源码大概过一遍启动流程。&lt;/p></description></item><item><title>lua语言入门</title><link>https://www.fewth.com/lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</link><pubDate>Sun, 01 Aug 2021 08:43:19 +0000</pubDate><guid>https://www.fewth.com/lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</guid><description>&lt;h2 id="1-变量">1 变量&lt;/h2>
&lt;h3 id="变量名称">变量名称&lt;/h3>
&lt;p>变量由字母、数字、下划线组成，但不能由数字开头，且不建议&lt;code>_A**&lt;/code>这种下划线后接大写字母的方式，通常作为Lua内部特殊用途。下面的几个词是&lt;code>Lua&lt;/code>保留的关键字：&lt;/p></description></item><item><title>回溯-backtracking</title><link>https://www.fewth.com/%E5%9B%9E%E6%BA%AF-backtracking/</link><pubDate>Wed, 23 Jun 2021 14:41:47 +0000</pubDate><guid>https://www.fewth.com/%E5%9B%9E%E6%BA%AF-backtracking/</guid><description>&lt;h2 id="1-简介">1 简介&lt;/h2>
&lt;p>回溯是一种算法思想，通常借助递归实现，核心就是记录相应的状态值，以降低&amp;quot;试错成本&amp;quot;。&lt;/p></description></item><item><title>用github actions自动化布署hexo博客-从私有仓库到公共仓库</title><link>https://www.fewth.com/%E7%94%A8github-actions%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2-%E4%BB%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%88%B0%E5%85%AC%E5%85%B1%E4%BB%93%E5%BA%93/</link><pubDate>Tue, 08 Jun 2021 15:44:46 +0000</pubDate><guid>https://www.fewth.com/%E7%94%A8github-actions%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2-%E4%BB%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%88%B0%E5%85%AC%E5%85%B1%E4%BB%93%E5%BA%93/</guid><description>&lt;p>常规的hexo使用方式如下：&lt;br>
写markdown文件保存-&amp;gt;&lt;code>hexo generate&lt;/code>生成文件-&amp;gt;&lt;code>hexo deploy&lt;/code>部署到github仓库-&amp;gt;把源文件备份到博客仓库的source分支或者备份到一个私有仓库&lt;/p>
&lt;p>利用&lt;code>Github-Actions&lt;/code>+&lt;code>Powershell脚本&lt;/code>可以把写博客的流程简化为：&lt;br>
写markdown文件保存-&amp;gt;打开powershell，输入&lt;code>pushhexo&lt;/code>指令完成上面的所有步骤&lt;/p></description></item><item><title>jvm之class文件及类加载机制和双亲委派模型</title><link>https://www.fewth.com/jvm%E4%B9%8Bclass%E6%96%87%E4%BB%B6%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</link><pubDate>Wed, 02 Jun 2021 16:04:54 +0000</pubDate><guid>https://www.fewth.com/jvm%E4%B9%8Bclass%E6%96%87%E4%BB%B6%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>本文先简单介绍虚拟机规范约定的&lt;code>class&lt;/code>文件格式，并从一个示例&lt;code>class&lt;/code>文件复原代码基本内容，最后描述虚拟机类加载机制以及介绍一下双亲委派模型。Java版本为11。&lt;/p></description></item><item><title>java注解</title><link>https://www.fewth.com/java%E6%B3%A8%E8%A7%A3/</link><pubDate>Fri, 07 May 2021 22:43:01 +0000</pubDate><guid>https://www.fewth.com/java%E6%B3%A8%E8%A7%A3/</guid><description>&lt;h2 id="1-java注解是什么">1 Java注解是什么?&lt;/h2>
&lt;p>根据&lt;a href="https://docs.oracle.com/javase/tutorial/java/annotations/">官方文档&lt;/a>说明，&lt;code>Java注解&lt;/code>是元数据的一种形式，它不直接影响我们代码本身的操作，但是有以下几个用途：&lt;/p>
&lt;ul>
&lt;li>给编译器提供信息-编译器可以用注解来检测错误或者抑制编译时的warning信息&lt;/li>
&lt;li>编译和部署代码时进一步加工&amp;mdash;一些工具可以根据注解生成额外的代码或文件&lt;/li>
&lt;li>运行时处理：一些注解可以在运行时被检测&lt;/li>
&lt;/ul></description></item><item><title>elasticsearch分布式搜索引擎</title><link>https://www.fewth.com/elasticsearch%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</link><pubDate>Tue, 27 Apr 2021 21:24:48 +0000</pubDate><guid>https://www.fewth.com/elasticsearch%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</guid><description>&lt;h2 id="1-elasticsearch是什么">1 elasticsearch是什么&lt;/h2>
&lt;p>es是一个分布式的搜索和分析数据的引擎。es是基于&lt;code>Apache Lucene&lt;/code>开发的，&lt;code>Apache Lucene&lt;/code>库提供了很多API，但是偏底层，没有进行封装的话在项目中直接使用是很不方便的。&lt;/p>
&lt;p>es本身可以存储和读取数据，那么跟数据库有什么不同呢？&lt;/br>&lt;/p></description></item><item><title>windows用docker部署redis集群</title><link>https://www.fewth.com/windows%E7%94%A8docker%E9%83%A8%E7%BD%B2redis%E9%9B%86%E7%BE%A4/</link><pubDate>Wed, 14 Apr 2021 12:23:02 +0000</pubDate><guid>https://www.fewth.com/windows%E7%94%A8docker%E9%83%A8%E7%BD%B2redis%E9%9B%86%E7%BE%A4/</guid><description>&lt;h2 id="1-预备知识">1 预备知识&lt;/h2>
&lt;p>除了知道&lt;code>Docker&lt;/code>和&lt;code>Redis cluster&lt;/code>的基本概念和常规部署流程外，还需要知道&lt;code>Docker&lt;/code>里的几个概念：&lt;/p></description></item><item><title>java泛型和c++模板的区别</title><link>https://www.fewth.com/java%E6%B3%9B%E5%9E%8B%E5%92%8Cc-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Fri, 26 Mar 2021 09:11:35 +0000</pubDate><guid>https://www.fewth.com/java%E6%B3%9B%E5%9E%8B%E5%92%8Cc-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>&lt;p>主要介绍java泛型，再与C++模板作一个简单的比较。&lt;/p></description></item><item><title>java内部类和嵌套接口</title><link>https://www.fewth.com/java%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3/</link><pubDate>Tue, 17 Nov 2020 10:54:40 +0000</pubDate><guid>https://www.fewth.com/java%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3/</guid><description>&lt;p>主要介绍内部类，顺便提一下接口中的嵌套接口和嵌套类。&lt;/p>
&lt;h2 id="1内部类">&lt;strong>1.内部类&lt;/strong>&lt;/h2>
&lt;p>内部类是定义在其它类中的类。这个定义很宽泛，因为内部类也可以定义在类中的方法里，可以用匿名内部类，还可以声明为public、private、protected、static，不同的情形下，内部类表现也不一致，分别举例说明。&lt;/p></description></item><item><title>spring boot用java bean validation进行数据验证</title><link>https://www.fewth.com/spring-boot%E7%94%A8java-bean-validation%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/</link><pubDate>Fri, 13 Nov 2020 10:03:59 +0000</pubDate><guid>https://www.fewth.com/spring-boot%E7%94%A8java-bean-validation%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/</guid><description>&lt;blockquote>
&lt;p>概述：以一个web项目中的用户注册服务为例子，介绍使用java bean validation进行数据验证的过程。&lt;/p>
&lt;/blockquote></description></item><item><title>后端处理数据格式验证及统一处理异常</title><link>https://www.fewth.com/%E5%90%8E%E7%AB%AF%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%8F%8A%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 02 Nov 2020 22:22:27 +0000</pubDate><guid>https://www.fewth.com/%E5%90%8E%E7%AB%AF%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%8F%8A%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</guid><description>&lt;p>对于前后端分离的项目，后端对于前端发送的数据进行验证是必要的，但这不表示前端的验证就没必要，比如一些数据的格式问题可以在前端完成验证，快速返回结果给用户，提升用户体验。&lt;/p>
&lt;p>这里以一个简单的用户注册服务举例，代码部分主要展示逻辑和框架。&lt;/p>
&lt;p>主要思路：前端发送用户注册提交的表单信息，后端接收后在service层进行格式验证，如果格式不符合要求，则抛出相应异常，最后统一在controller层进行异常的拦截处理，返回特定的json信息。&lt;/p></description></item><item><title>aes前端密码加密后端java解密的一些记录</title><link>https://www.fewth.com/aes%E5%89%8D%E7%AB%AF%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E5%90%8E%E7%AB%AFjava%E8%A7%A3%E5%AF%86%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</link><pubDate>Tue, 08 Sep 2020 19:41:34 +0000</pubDate><guid>https://www.fewth.com/aes%E5%89%8D%E7%AB%AF%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E5%90%8E%E7%AB%AFjava%E8%A7%A3%E5%AF%86%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</guid><description>&lt;p>本文主要讲前端传输时的密码加密及后端收到密文后解密的过程，避免明文传输密码，文中内容都比较浅显，加密原理部分需要查阅其它资料。至于前端加密是否有意义，见仁见智。&lt;/p>
&lt;h2 id="环境">环境&lt;/h2>
&lt;p>前端用的&lt;code>vue&lt;/code>，纯JS也可以，引入&lt;code>crypto-js&lt;/code>库，后端用&lt;code>java&lt;/code>。&lt;/p>
&lt;h2 id="加密方法modepadding的选择">加密方法、MODE、PADDING的选择&lt;/h2>
&lt;p>这几个参数之间相互有关联，且前后端加密、解密时的参数必须一致。&lt;/p>
&lt;p>有的参数前端有A选项，但是后端没有对应的选项，反之也存在后端有B选项，但前端没有的，选择的时候只能选前后端都有的。&lt;/p>
&lt;p>具体可以从下面两篇文档中看到：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://cryptojs.gitbook.io/docs/#pbkdf2">前端cypto-js参考文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">后端java参考文档&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>三个参数前后端共有的选项分别是：&lt;/p>
&lt;ul>
&lt;li>加密方法：&lt;code>AES&lt;/code>、&lt;code>DES&lt;/code>、 &lt;code>Triple DES&lt;/code>(java对应&lt;code>DESede&lt;/code>)、&lt;code>RC4&lt;/code>&lt;/li>
&lt;li>mode：&lt;code>CBC&lt;/code>、&lt;code>CFB&lt;/code>、&lt;code>CTR&lt;/code>、&lt;code>OFB&lt;/code>、&lt;code>ECB&lt;/code>&lt;/li>
&lt;li>padding:&lt;code>NoPadding&lt;/code>、&lt;code>Iso10126&lt;/code>、&lt;code>Pkcs7 &lt;/code>(java对应&lt;code>PKCS5Padding&lt;/code>)&lt;/li>
&lt;/ul></description></item><item><title>用vue和element-ui不借助vuex实现弹窗登录</title><link>https://www.fewth.com/%E7%94%A8vue%E5%92%8Celement-ui%E4%B8%8D%E5%80%9F%E5%8A%A9vuex%E5%AE%9E%E7%8E%B0%E5%BC%B9%E7%AA%97%E7%99%BB%E5%BD%95/</link><pubDate>Tue, 01 Sep 2020 13:03:40 +0000</pubDate><guid>https://www.fewth.com/%E7%94%A8vue%E5%92%8Celement-ui%E4%B8%8D%E5%80%9F%E5%8A%A9vuex%E5%AE%9E%E7%8E%B0%E5%BC%B9%E7%AA%97%E7%99%BB%E5%BD%95/</guid><description>&lt;blockquote>
&lt;p>本文主要介绍不使用vuex的情况下，通过父子组件传值通信等方法达到弹窗登录的目的。在生产环境中，使用vuex会非常的方便，通过store去维护一个&amp;quot;isLoginVisible&amp;quot;变量即可。&lt;/p>
&lt;/blockquote>
&lt;h2 id="主要思路">主要思路&lt;/h2>
&lt;p>首先，在同一个页面文件中实现弹窗功能一般没什么问题，定义一个状态变量控制组件的显示就行了。这里主要介绍弹窗作为一个单独的单文件组件时的情况，涉及父子组件通信及属性绑定的问题。&lt;/p>
&lt;p>实现：&lt;/p></description></item><item><title>vue中的大小写</title><link>https://www.fewth.com/vue%E4%B8%AD%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99/</link><pubDate>Sun, 16 Aug 2020 16:46:45 +0000</pubDate><guid>https://www.fewth.com/vue%E4%B8%AD%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99/</guid><description>&lt;p>命名方法主要分三种,效果如其名称:&lt;/p>
&lt;p>camelCase&lt;/p>
&lt;p>kebab-case&lt;/p>
&lt;p>PascalCase&lt;/p>
&lt;p>首先，DOM模板内部元素的属性名称是不区分大小写的，比如以下三种表示是等价的：&lt;/p></description></item><item><title>vue生命周期勾子</title><link>https://www.fewth.com/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8B%BE%E5%AD%90/</link><pubDate>Sun, 16 Aug 2020 16:44:21 +0000</pubDate><guid>https://www.fewth.com/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8B%BE%E5%AD%90/</guid><description>&lt;p>官方原图：
&lt;img src="https://cn.vuejs.org/images/lifecycle.png" alt="img">
上图中红色部分为常用的&lt;strong>实例生命周期钩子&lt;/strong>，可以用在vue实例运行的各个阶段，按大概时间线：&lt;/p></description></item><item><title>在windows中安装使用redis的几种方法</title><link>https://www.fewth.com/%E5%9C%A8windows%E4%B8%AD%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8redis%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link><pubDate>Tue, 28 Jul 2020 22:49:54 +0000</pubDate><guid>https://www.fewth.com/%E5%9C%A8windows%E4%B8%AD%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8redis%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid><description>&lt;p>redis主要是运行在linux下的，官网没有提供windows版本，可以通过以下几种方法在windows系统下使用redis，部分方法只适用于win10。&lt;/p></description></item><item><title>javascript中__proto__和prototype的区别</title><link>https://www.fewth.com/javascript%E4%B8%AD__proto__%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Tue, 28 Jul 2020 21:40:18 +0000</pubDate><guid>https://www.fewth.com/javascript%E4%B8%AD__proto__%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>&lt;p>prototype是函数特有的属性，一个对象的构造函数也是函数，js中没有类，只有构造函数。关于原型链的继承在这里不展开。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>__proto__&lt;/code>属性已经被标记为deprecated，可以用&lt;code>Object.getPrototypeOf(obj)&lt;/code>的方式代替访问该属性，应该避免修改该属性，因为它会影响到所有跟这个属性有关的对象，性能非常低下，可以用&lt;code>Object.create(targetproto)&lt;/code>的方式直接用你希望的原型创建一个新的对象。&lt;/p>
&lt;/blockquote></description></item><item><title>windows用powershell连接vps(以googlecloud为例）</title><link>https://www.fewth.com/windows%E7%94%A8powershell%E8%BF%9E%E6%8E%A5vps%E4%BB%A5googlecloud%E4%B8%BA%E4%BE%8B/</link><pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.fewth.com/windows%E7%94%A8powershell%E8%BF%9E%E6%8E%A5vps%E4%BB%A5googlecloud%E4%B8%BA%E4%BE%8B/</guid><description>&lt;blockquote>
&lt;p>Powershell已经内置OpenSSH,用起来比Xshell还方便，并且用root账号或开启密码登陆都存在安全隐患，所以这里只介绍普通用户+ssh的登陆方式。&lt;/p>
&lt;/blockquote>
&lt;p>基本步骤：&lt;/p></description></item></channel></rss>