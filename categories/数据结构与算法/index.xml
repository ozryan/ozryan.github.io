<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据结构与算法 on A few thoughts</title><link>https://www.fewth.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link><description>Recent content in 数据结构与算法 on A few thoughts</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 24 Oct 2021 17:09:19 +0000</lastBuildDate><atom:link href="https://www.fewth.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>第k个顺序统计量(数组中第k小的元素)</title><link>https://www.fewth.com/%E7%AC%ACk%E4%B8%AA%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</link><pubDate>Sun, 24 Oct 2021 17:09:19 +0000</pubDate><guid>https://www.fewth.com/%E7%AC%ACk%E4%B8%AA%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</guid><description>&lt;p>要从一个数组中找出第k小的元素，最容易想到的是快速排序，但是快速排序解决这个问题有很多不必要的操作，在快速排序中，根据“哨兵”元素把数组分成两部分，然后对两部分进行递归处理，第k个顺序统计量的算法也借鉴这种思路，我们称为“快速选择(quick select)算法”,但是快速选择算法每次只需要处理第K个元素所在的那一部分就行，我们的目的只是找到目标元素，随着递归次数的深入，快速选择算法要处理的元素会越来越少（而快速排序随着递归的深入，每次递归处理的元素总数依然是n），这种差别是很大的，后面分析时间复杂度时可以得知快速选择算法的期望运行时间是$\theta(n)$。&lt;/p>
&lt;h3 id="算法实现">算法实现&lt;/h3>
&lt;p>快速选择算法跟快速排序类似，主要步骤就是分组算法：根据哨兵元素把数组分成两组，一组小于哨兵，一组大于哨兵，然后进行递归调用。&lt;/p></description></item><item><title>回溯(backtracking)</title><link>https://www.fewth.com/%E5%9B%9E%E6%BA%AFbacktracking/</link><pubDate>Wed, 23 Jun 2021 14:41:47 +0000</pubDate><guid>https://www.fewth.com/%E5%9B%9E%E6%BA%AFbacktracking/</guid><description>&lt;h2 id="1-简介">1 简介&lt;/h2>
&lt;p>回溯是一种算法思想，通常借助递归实现，核心就是记录相应的状态值，以降低&amp;quot;试错成本&amp;quot;。&lt;/p></description></item></channel></rss>